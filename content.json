[{"title":"cssworld03.md","date":"2018-05-06T05:18:55.000Z","path":"2018/05/06/cssworld03/","text":"","tags":[]},{"title":"盒尺寸四大家族","date":"2018-05-06T05:18:37.000Z","path":"2018/05/06/cssworld02/","text":"了解\bcontent/padding/margin 4 盒尺寸四大家族4.1 深入理解content4.1.1 contnet 与替换元素 什么是替换元素 通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。典型的替换元素 &lt;img&gt;,&lt;object&gt;,video,&lt;iframe&gt;,&lt;textarea&gt;,&lt;input&gt; 内容外观不受页面上的css的影响 有自己的尺寸 在很多css属性上有自己的一套表现规则 替换元素的默认的display值 所有的替换元素都是内联水平元素。替换元素的display值对于其尺寸计算规则无影响。 替换元素的尺寸计算规则 替换元素的尺寸：固有尺寸、HTML尺寸、CSS尺寸 如果没有CSS尺寸和HTML尺寸则使用固有尺寸作为最终的宽高 如果没有CSS尺寸则使用HTML尺寸 如果存在CSS尺寸，则最终尺寸由CSS属性决定 如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或者仅设置了高度，则元素依然按照固有的宽高比例显示。 如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。宽高比2:1。 内联替换元素和块级替换元素使用上面同一套尺寸计算规则。 替换元素和非替换元素的距离 替换元素如img去掉src属性则是普通非替换元素。 12345678&lt;style&gt; img &#123; display: block; border: 1px solid #eee; &#125;&lt;/style&gt;&lt;!-- alt为任意值 --&gt;&lt;img alt=\"1\"&gt; 此时img的宽度100%自适应父级容器 非替换元素和替换元素只隔了一个CSScontent属性 1234567 h1 &#123; content: url(../th.jpg); width: 50px; height:50px; &#125;&lt;!-- 普通元素content --&gt; &lt;h1&gt;图片&lt;/h1&gt; 此时h1就是一个50*50的图片 4.2 温和的padding属性4.2.2 padding的百分比值padding百分比值无论是水平方向还是垂直方向均是相对于宽度来计算。 实际使用实例可以做自适应的等比矩形。 12345678910111213141516&lt;style&gt; .img-wrapper &#123; position: relative; padding: 50%; &#125; .img-wrapper &gt; img &#123; position: absolute; width: 100%; height: 100%; left:0; top:0; &#125;&lt;/style&gt; &lt;div class=\"img-wrapper\"&gt; &lt;img src=\"../th.jpg\" alt=\"1\" &gt;&lt;/div&gt; 内联元素的padding padding相对宽度计算 默认的高度的宽度细节有差异 padding 会断行 4.3 激进的margin属性4.3.1 margin与元素尺寸以及相关布局 margin 与元素的内部尺寸 marign改变元素的可视尺寸与padding相反。对于paddding，元素设定了width属性或者保持包裹性的时候，会改变元素可视尺寸。而margin则无视之，只有当元素是“充分利用可用空间”状态的时候，margin才可以改变元素的可视尺寸。 12345678910111213141516171819&lt;style&gt; .father &#123; padding:0 10px ; &#125; .son &#123; margin: 0 -10px; line-height: 20px; text-align: center; background-color:#e1e1e1; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- marigin 改变子级宽度 --&gt; &lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;barfoo&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 4.3.4 深入理解CSS中的margin:auto触发margin:auto计算有个前提条件就是width或者height为auto时，元素是具有对应方向的自动填充特性。(比如块状元素的width默认100%继承父级，绝对定位元素的格式化宽度和高度) marigin:auto的填充规则 如果一侧定值,一侧auto,则auto为剩余空间。 如果两侧均是auto,则平分剩余空间。 针对第一条可以实现块状元素的左右对齐(而不是只有通过float:left/right) 例子（利用content生成伪元素以及margin:auto实现常见布局）123456789101112131415161718192021222324252627282930313233343536 &lt;style&gt; .home-icon-item:after &#123; position: absolute; display: inline-block; content: ''; width: 50px; height: 50px; left: 0; top: 0; right: 0; bottom: 0; margin: auto; border-radius: 50%; z-index: -1; &#125; &lt;/style&gt; &lt;div class=\"home-icon-wrapper\"&gt; &lt;div class=\"home-icon-item\"&gt; &lt;i class=\"iconfont\"&gt;1&lt;/i&gt; &lt;span class=\"text\"&gt;培训&lt;/span&gt; &lt;/div&gt; &lt;div class=\"home-icon-item\"&gt; &lt;i class=\"iconfont\"&gt;2&lt;/i&gt; &lt;span class=\"text\"&gt;会议&lt;/span&gt; &lt;/div&gt; &lt;div class=\"home-icon-item\"&gt; &lt;i class=\"iconfont\"&gt;3&lt;/i&gt; &lt;span class=\"text\"&gt;学员服务&lt;/span&gt; &lt;/div&gt; &lt;div class=\"home-icon-item\"&gt; &lt;i class=\"iconfont\"&gt;4&lt;/i&gt; &lt;span class=\"text\"&gt;资料下载&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 4.4功勋卓越的border属性4.4.3 border-color和colorborder-color 有一个很重要也很实用的特性，就是“border-color默认颜色就是color色值”。根据这个特性可以做个简单的边框hover变色实例。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .border &#123; position: relative; width: 80px; height:80px; border:2px dashed; color: #e3e3e3; &#125; .border:hover &#123; color:red; &#125; .border::after &#123; position: absolute; display: block; content: ''; width:40px; height: 40px; border-top:6px solid; top:40px; left:40px; margin-top: -3px; margin-left: -20px; &#125; .border::before &#123; position: absolute; display: block; content: ''; width:40px; height: 40px; top:40px; left:40px; margin-top: -20px; margin-left: -3px; border-left:6px solid; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- border属性缺省 --&gt; &lt;div class=\"border\"&gt; &lt;/div&gt;&lt;/body&gt; 例子（利用border和margin实现等分布局） 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; .bg &#123; padding: 15px 30px; background-color: #e1e1e1; &#125; .ul-wrapper &#123; padding-left: 0; margin-right: -15px; &#125; .ul-wrapper::after &#123; display: block; content: ''; clear: both; &#125; .li-item &#123; float: left; width:25% ; box-sizing: border-box; border-right: 15px solid transparent; list-style-type:none; &#125; .color &#123; height: 150px; background-color: #08c; &#125;&lt;/style&gt; &lt;!-- margin 等分布局 --&gt; &lt;div class=\"bg\"&gt; &lt;p &gt;管理中心&lt;/p&gt; &lt;ul class=\"ul-wrapper\"&gt; &lt;li class=\"li-item\"&gt; &lt;div class=\"color\"&gt;&lt;/div&gt; &lt;/li&gt; &lt;li class=\"li-item\"&gt; &lt;div class=\"color\"&gt;&lt;/div&gt; &lt;/li&gt; &lt;li class=\"li-item\"&gt; &lt;div class=\"color\"&gt;&lt;/div&gt; &lt;/li&gt; &lt;li class=\"li-item\"&gt; &lt;div class=\"color\"&gt;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 两种等高布局 border margin + padding 12345678910111213141516171819202122232425262728293031323334&lt;style&gt;.border-box &#123; margin: 10px 0; border-left:150px solid #c7c7c7; background-color: #f1f1f1; &#125;/* 此处不能用overflow:hidden清除浮动否则左浮动的导航列表元素就会被隐藏掉 */.border-box::after &#123; display: block; content: ''; clear: both;&#125;.border-box &gt; nav &#123; width: 150px; margin-left: -150px; float: left; text-align: center; &#125;&lt;/style&gt; &lt;!-- border等高布局--&gt;&lt;div class=\"border-box\"&gt; &lt;nav&gt; &lt;h3&gt;导航1&lt;/h3&gt; &lt;h3&gt;导航2&lt;/h3&gt; &lt;/nav&gt; &lt;section&gt; &lt;h5&gt;模块1&lt;/h5&gt; &lt;h5&gt;模块2&lt;/h5&gt; &lt;h5&gt;模块3&lt;/h5&gt; &lt;/section&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728 &lt;style&gt; .margin-box &#123; overflow: hidden; &#125; .column-left ,.column-right &#123; width: 50%; float: left; padding-bottom: 9999px; margin-bottom: -9999px; &#125; .column-left &#123; background-color: #c7c7c7; &#125; .column-right &#123; background-color: #f1f1f1; &#125;&lt;/style&gt; &lt;!-- margin + padding 等高布局 --&gt;&lt;div class=\"margin-box\"&gt; &lt;div class=\"column-left\"&gt; &lt;h3&gt;导航1&lt;/h3&gt; &lt;h3&gt;导航2&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"column-right\"&gt; &lt;h4&gt;模块1&lt;/h3&gt; &lt;/div&gt;&lt;/div&gt;","tags":[{"name":"css","slug":"css","permalink":"https://liuchao0704.github.io/tags/css/"}]},{"title":"流、元素、基本尺寸","date":"2018-05-06T05:18:25.000Z","path":"2018/05/06/cssworld01/","text":"认识各种盒子以及width/height作用细节 3 流、元素、基本尺寸3.1 块级盒子（认识各种盒子）根据整个第三章第四章以及第五章的内容我把盒子模型之间的关系画了一个总的示意图。 3.2 width/height 作用的具体细节3.2.1 width:auto属性 充分利用可用空间 &lt;div&gt; ,&lt;p&gt;这些元素默认宽度100%充满父级 （外部尺寸） 收缩与包裹性 （内部尺寸） 收缩到最小 （内部尺寸） 超出容器限制 （内部尺寸） “外部尺寸”与“内部尺寸” 外部尺寸：宽度由外部元素决定 内部尺寸：宽度由内部元素决定 如果一个元素里面没有内容宽度为0 那么这个元素应用的就是“内部尺寸” 内部尺寸与流体特性 包裹性典型例子，按钮元素button具体表现为按钮文字越多宽度越宽。但是文字足够多，则会在容器的宽度处自动换行。PS按钮元素的最大宽度为240px。除了inline-block元素，浮动元素以及绝对定位元素都具有包裹性。 首选最小宽度 最大宽度实际等同于“包裹性”元素设置white-space:nowrap声明后的宽度。如果内部没有块级元素或者块级元素没有设定宽度值，则“最大宽度”实际上是最大的连续内联盒子的宽度 3.2.2 width值作用的具体细节 width作用在content box上 3.2.3 CSS流体布局下的宽度分离原则 不在同一层标签上设置width,padding。 width设置在父级标签上，子级标签设置padding,border属性。子级自适应父级宽度。 3.2.4 改变width作用细节的box-sizing box-sizing被发明的初衷更大的可能是解决替换元素宽度自适应问题。原因替换元素的尺寸由内部元素决定对于其设置display属性是inline还是block,替换元素的宽度都不会受其影响。 textarea的width100%自适应父级，同时保留border,padding属性只能通过box-sizing:border-box来解决 123input ,textarea, img, video, object &#123; box-sizing: border-box &#125; 3.2.5 height:autoheight:auto也有外部尺寸特性，仅存在于绝对定位模型中，也就是“格式化高度”。 3.2.6 height: 100%如何让元素支持height:100%? 设定显示的高度 123 html, body &#123; height: 100%;&#125; 使用绝对定位绝对定位元素百分比计算和非绝对定位元素的百分比计算是有区别的，区别在于绝对定位的宽高百分比计算是相对于padding box 12345.box &#123; position: absolute; width: 100%; height: 100%;&#125; 3.3 CSSmin-width/max-width和min-height/max-height3.3.2 与众不同的初始值min-width/min-height的初始值为automax-width/max-height的初始值为none (思考为什么max的初始值为none 而不是auto) 3.3.3 超越!important 超越最大简单的来说min和max的权重比!important大。 如果min和max设置起冲突的时候。min-width 会覆盖max-width。","tags":[{"name":"css","slug":"css","permalink":"https://liuchao0704.github.io/tags/css/"}]},{"title":"css总结 | 读css世界笔记","date":"2018-04-16T07:04:25.000Z","path":"2018/04/16/css3/","text":"2018年2月份入手了《css世界》一书。打算过年内看完，但是翻阅之后决定作为工具书多次阅读并记笔记总结之，加深自己对css的理解（源于我看第五章的时间线拉的比较长，几乎每次都要重头过一遍）当然最好要回归实践，否则理论永远只是理论。回想自己刚上手写css的时候先引入一段重置css然后再引入boostrap·css。随着页面越来越个性化，我发现写一段易修改，可维护，代码量少的css相当重要。 1 、流、元素、基本尺寸 !2 、盒尺寸四大家族 !3、","tags":[{"name":"css","slug":"css","permalink":"https://liuchao0704.github.io/tags/css/"}]},{"title":"游泳小记","date":"2018-04-09T12:42:16.000Z","path":"2018/04/09/swim/","text":"觉得为时已晚的时候,恰恰是最早的时候 Day1 （2018.04.09）一共十节课 今天是第一节。课时一个小时，主要学会了漂浮在水面、换气、手臂动作。刚开始入水我是恐惧的，不敢手臂远离墙壁，自身腰部也很紧张，腿部很沉，下半身很沉，总是飘不起来。就算勉强漂浮在水中，身体也极度不稳定，整个人像风雨中飘摇的船只，左右摇晃不定，容易翻身。对于这种情况，教练教了两种动作，一个是在水中自主站立的动作，双腿的膝盖靠近胸部，手臂向下挥舞 ，人就顺势站立起来。还有一种是感觉你要翻身的时候 ，脚尖绷紧，膝盖打直，手臂张开角度越大越好，手臂打直 ，手指尖绷紧。然后整个人就不容易翻身了。掌握了以后，就不怕对水的恐惧了。 开心ing。 Day2-5 （2018.04.10-04.13）整个四节课就练习划手和蹬腿，其中蹬腿的用的时间很长，我刚开始练习的时候犯了很多错误。 蹬腿必撅屁股 蹬腿身体滑行距离很小 蹬腿几次之后身体下半身越来越下沉 蹬腿像慢动作 首先蹬腿的时候 在小腿和脚后跟靠近屁股的同时，膝关节尽量打开 + 大腿不要太往池底靠，这样屁股就不会撅起来了。 蹬腿的时候 尽量保证身体的平稳性 不要操之过急，每次蹬腿完毕尽量让身体都稳定在水面中央 既不下沉的厉害，也不漂浮的厉害。 蹬腿要快要用力 Day6 （2018.04.15）今天蹬腿和划手有点感觉了，滑行的距离也出来了。明天可以练习一下综合了 Day1N (2018.05.06)应该练习了有十几天，五一假期三天连续练习，能游一个来回，但是蹬腿的距离太短，以至于不停的蹬腿才能保持前进。初步判断是人未达到平行的状态就蹬腿，导致一部分前进的力量被分解为向上的力量。后期注意蹬腿时机。","tags":[{"name":"生活","slug":"生活","permalink":"https://liuchao0704.github.io/tags/生活/"},{"name":"游泳","slug":"游泳","permalink":"https://liuchao0704.github.io/tags/游泳/"}]},{"title":"个人简历","date":"2018-03-01T13:45:43.000Z","path":"2018/03/01/resume/","text":"刘超 程序媛 南京信息工程大学 本科 电子信息工程 2820501417@qq.com 无锡 1991-07 https://liuchao0704.github.io/ 2016至今我在无锡乐伏能源有限公司从事前端开发。乐伏能源是一家光伏监控与运维解决方案的提供商。我有幸在公司创业之初就加入。经历了从无到有，初代产品研发以及后期功能的升级和迭代。主要为公司开发PC端网页系统以及移动端webApp。 Web定制版中国航天智慧能源管理平台 （Aerospace smart energy management system ）为中国航天定制开发的大屏监控系统（适合2560x1440以上分辨率）于2018年8月上线。本人负责该项目的前期沟通/需求整理/界面风格确认工作。1、分析客户基本需求：资产管理 &amp; 能量管理。2、结合公司现有系统功能提炼并改造。为中国航天开发了去菜单化一键查看数据流程。满足了非专业人士也能便捷操作能源站系统的需求。 移动端乐伏管家app该App可以同时满足个人业主和大型安装商对电站运营情况的查询和运维需求。2018年3月上线，累计下载量10000+。本人负责该项目产品需求整理和前端开发工作。采用AngularJs + betterscroll。betterscroll是一款优秀的滚动插件，它可以优化WebApp的滚动体验，使webApp中超长页更接近原生App的滚动效果。视觉层面：根据电站的天气情况个性化设置页面，新增晴天/阴天/多云/雨/雪/夜间模式并动态更新页面，带来不一样的视觉体验数据存储：利用AngularJs 的$rootscope作为简易版本的根数据管理，在$rootscope创建根对象用于存储多次复用并且实时更新的数据。 乐伏运维app该App可以满足终端业主及运维人员对于电站运维的需求。2017年9月上线，累计下载量1000+。本人负责该项目的前端开发工作。针对第一版的乐伏监控App 的一些问题。我决定将此App开发成webApp。AngularJs框架满足了App的路由切换和多角色分配。优点如下： 采用ajax与后台交互数据 版本合一 android 和 ios 使用一个版本 不需要维护多版本 路由切换更加自然 更接近原生app PC端乐伏运维系统网页版乐伏电站运维系统网页版是一款为终端业主+运维人员+电站集成商打造的电站运维系统 。于2017年8月上线。 本人负责该项目的前端开发工作。乐伏运维系统采用AngualrJs框架将三种不同的电站管理角色紧密联系到一起，便于及时排除和解决电站的故障问题。该软件的主要开发功能如下： 不同用户角色不同权限的页面展示 集成简易的物料管理系统 运单不同状态下的可操作流程、功能 目前在电站运维系统的注册的电站已经达到6000+，平均每日完成电站运维任务数达到100+。 乐伏电站设计系统网页版乐伏电站设计系统是一款实用的电站设计系统。于2017年3月份上线。本人负责该项目的前端开发工作。乐伏电站设计系统采用AngualrJs框架。该软件方便用户进行电站预估计算及设备选型。用户无需要专业的电站知识即可进行一键式计算收益和组件、设备匹配，使电站获得最佳收益。 高德地图支持用户快速自定义电站位置 获取该地理位置的辐照量和最佳倾斜角 用户自定义组件方案设计保存 打印自定义方案 乐伏电站监控系统网页版乐伏监控系统网页版是一款功能丰富的电站监控系统，于2017年1月上线 。本人负责该项目的前端开发工作。乐伏电站监控系统采用AngualrJs框架。 angularJS 负责数据双向绑定 ui-router + animate.css 负责SPA(单页面应用)路由切换以及切换效果 ng-repeat 列表的分页渲染 angular 内置form validate 配合正则表达式验证表单（用户注册/登录/电站个添加/设备添加） bootstrap datepicker + highchart 图表展示 bootstrap datepicker 支持单日期的自由选择以及任意 时间段选择 highchart插件中的柱状图、折线图、 饼状图 、仪表图等形式 为电站/设备发电量、功率等数据展示提供了直观的视觉效果。 bootstrap 栅格系统快速搭建后台管理系统页面","tags":[{"name":"简历","slug":"简历","permalink":"https://liuchao0704.github.io/tags/简历/"}]},{"title":"常用正则表达式整理","date":"2018-02-01T13:45:43.000Z","path":"2018/02/01/reg/","text":"将常用的正则表达式整理如下。 常用正则表达式整理正则元字符 字符 描述 * 匹配前面的字表达式零次或者多次等价于{0,} + 匹配前面的字表达式一次或者多次等价于{1,} ? 匹配前面的字表达式零次或者一次等价于{0,1} 整数(不限制正负)/^-?\\d+$/; // 不限制长度 整数(&gt; 0)/^[1-9]\\d*$/; // 不限制长度 /^[1-9]\\d{0,5}$/;// 限制长度 整数(&gt; 0 &amp;&amp; &lt;= 100)/^(100|([1-9]{1}\\d?))$/ 浮点型(&gt; 0 保留2位小数)/^(([1-9]{1})(\\.\\d{1,2})?|(0(\\.\\d{0,1}[1-9])))$/ /^(([1-9]{1}[0-9]{0,5})(\\.\\d{1,2})?|(0(\\.\\d{0,1}[1-9])))$/ 浮点型(&gt;= 0 保留2位小数)/^(([1-9]{1})(\\.\\d{1,2})?|(0(\\.\\d{0,1}[1-9])?))$/ 字符串开头不能空格 中间可以是空格/数字/字母/中文/非特殊字符结尾/^[\\w\\u4e00-\\u9fa5]{1}[\\s\\w\\u4e00-\\u9fa5]{0,8}$/","tags":[{"name":"reg","slug":"reg","permalink":"https://liuchao0704.github.io/tags/reg/"}]},{"title":"学以致用系列之js array","date":"2018-01-28T10:46:46.000Z","path":"2018/01/28/jsArray/","text":"最近学react,对于数据操作特别是数组的操作让我有了新的认识,现在将数组的一些方法记录下来,并且改造一下之前angular js checkbox全选和选不选的js。希望自己写出更加优雅的代码(少用if，else)。 一行代码搞定Array的深拷贝1var data = data.conact(); // js contacat() 方法会返回一个新的数组。tips：原数组中如有对象,还是不能做到完全的深拷贝。 数组的过滤 filter()原来我操作的数组的思路是循环数组找到index,然后用数组的splice(index, 1)删除。其实就是filter()应该干的事情。 改写Angular JS动态控制多选框全选与全不选并且打印选中的值]点击查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script src=\"angular-1.3.0.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=\"myApp\" ng-controller=\"vipApplyEditCtrl\"&gt;&lt;div&gt; &lt;input type=\"checkbox\" name=\"all\" ng-model=\"all\" ng-change=\"toSelectAll(all)\"&gt; 全选 &lt;i&gt;&#123;&#123;all&#125;&#125;&lt;/i&gt; &lt;div ng-repeat=\"color in colors\"&gt; &lt;input type=\"checkbox\" ng-checked=\"color.checked == true\" ng-click=\"updateSelection(color)\" /&gt; &#123;&#123;color.name&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;div&gt; Selected :&#123;&#123;selected&#125;&#125;&lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller(\"vipApplyEditCtrl\", function($scope) &#123; $scope.formData = &#123;&#125;; $scope.colors = [ &#123;id : 1, name : 'black'&#125;, &#123;id : 2, name : 'red'&#125;, &#123;id : 3, name : 'blue'&#125;, &#123;id : 4, name : 'yellow'&#125;, &#123;id : 5, name : 'green'&#125;, &#123;id : 6, name : 'white'&#125; ] ; $scope.selected = [] ; // 存放新的已选数据 $scope.updateSelection = function(obj)&#123; obj.checked = !obj.checked; $scope.selected = [] ; $scope.colors.forEach(function(item)&#123; if(item.checked)&#123; $scope.selected.push(item.id) ; &#125; &#125;) $scope.colors.every(function(item)&#123; return item.checked ; &#125;) &#125;; $scope.toSelectAll = function(flag)&#123; $scope.selected = []; $scope.colors.forEach(function(i)&#123; i.checked = flag; if(flag)$scope.selected.push(i.id); &#125;) &#125;&#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"js","slug":"js","permalink":"https://liuchao0704.github.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://liuchao0704.github.io/tags/array/"}]},{"title":"Sticky footer 布局","date":"2018-01-06T05:18:37.000Z","path":"2018/01/06/stickyfooter/","text":"css3的一种经典布局。footer紧紧粘在底部，当页面内容不足一页的时候，footer在最底部。当页面内容超过一页，footer自动在底部。 sticky footer 布局sticky-footer布局思路1父元素包裹内容，并给他一个内边距使其等于底部的高度，防止内容覆盖到底部的内容。底部元素有个负的margin值 css3 代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; html, body &#123; height: 100%; margin: 0; &#125; .wrapper &#123; min-height: 100%; &#125; .clearfix::after &#123; display: block; content: \".\"; height: 0; clear: both; visibility: hidden; &#125; .content-inside &#123; padding-top: 20px; padding-left: 20px; padding-right: 20px; padding-bottom: 50px; &#125; .content-inside&gt;p &#123; line-height: 60px; margin: 0; &#125; .footer &#123; height: 50px; margin-top: -50px; background-color: #00b3ee; text-align: center; color: white; font-size: 24px; line-height: 50px; &#125; &lt;/style&gt; div布局123456789101112131415161718 &lt;body&gt; &lt;div class=\"wrapper clearfix\"&gt; &lt;div class=\"content-inside\" id=\"div\"&gt; &lt;h1&gt;content&lt;/h1&gt; &lt;button onclick=\"addP()\"&gt;点击添加文字&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;footer class=\"footer\"&gt;footer&lt;/footer&gt; &lt;script&gt; var element = document.getElementById(\"div\"); function addP() &#123; var para = document.createElement(\"p\"); var node = document.createTextNode('这是一个新段落'); para.appendChild(node); element.appendChild(para); &#125; &lt;/script&gt;&lt;/body&gt; sticky footer 布局思路21234&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt;这里是主要内容&lt;/div&gt; &lt;div class=\"footer\"&gt;这是页脚区块&lt;/div&gt; &lt;/div&gt; 1234567891011.wrapper &#123; display: flex; flex-direction: column; min-height: 100vh;&#125;.content &#123; flex: 1;&#125;.footer &#123; flex: 0;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://liuchao0704.github.io/tags/css/"}]},{"title":"js 基本类型学习总结","date":"2017-12-31T14:02:20.000Z","path":"2017/12/31/js/","text":"看完js高级程序之后对js基本类型的学习和总结 类型、值、变量JavaScript的数据类型分为类型： 基本类型（原始类型)和引用类型(对象类型) 基本类型 Undefined,Null,Boolean,Number,String,Symbol (ECMAScript 6 新定义) 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 不可改变的原始值和可变的对象引用 原始值是不可更改的，任何方法都无法更改一个原始值。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值 typeof判断数据类型typeof操作符返回一个字符串指示未经计算的操作数的类型。 类型 结果 Undefined “undefined” Null “object” (见下方) Boolean “boolean” Number “number” String “string” Symbol (ECMAScript 6 新增) “symbol” 宿主对象(由JS环境提供) Implementation-dependent 函数对象 ( [[Call]] 在ECMA-262条款中实现了) “function” 任何其他对象 “object” typeof实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Numberstypeof 37 === 'number';typeof 3.14 === 'number';typeof Math.LN2 === 'number';typeof Infinity === 'number';typeof NaN === 'number'; // 尽管NaN是\"Not-A-Number\"的缩写typeof Number(1) === 'number'; // 但不要使用这种形式!// Stringstypeof \"\" === 'string';typeof \"bla\" === 'string';typeof (typeof 1) === 'string'; // typeof总是返回一个字符串typeof String(\"abc\") === 'string'; // 但不要使用这种形式!// Booleanstypeof true === 'boolean';typeof false === 'boolean';typeof Boolean(true) === 'boolean'; // 但不要使用这种形式!// Symbolstypeof Symbol() === 'symbol';typeof Symbol('foo') === 'symbol';typeof Symbol.iterator === 'symbol';// Undefinedtypeof undefined === 'undefined';typeof declaredButUndefinedVariable === 'undefined';typeof undeclaredVariable === 'undefined'; // Objectstypeof &#123;a:1&#125; === 'object';// 使用Array.isArray 或者 Object.prototype.toString.call// 区分数组,普通对象typeof [1, 2, 4] === 'object';typeof new Date() === 'object';// 下面的容易令人迷惑，不要使用！typeof new Boolean(true) === 'object';typeof new Number(1) ==== 'object';typeof new String(\"abc\") === 'object';// 函数typeof function()&#123;&#125; === 'function';typeof class C&#123;&#125; === 'function'typeof Math.sin === 'function'; 判断数组的几种方法 typeof &amp;&amp; length instanceof Array.isArray() typeof：数组有length属性，object没有1234567891011121314151617181920var o = &#123; 'name':'lee' &#125;; // 对象var a = ['reg','blue']; // 数组 var getDataType = function(o)&#123; if(typeof o == 'object')&#123; if( typeof o.length == 'number' )&#123; return 'Array'; &#125;else&#123; return 'Object'; &#125; &#125;else&#123; return 'param is no object type'; &#125;&#125;; alert( getDataType(o) ); // Objectalert( getDataType(a) ); // Arrayalert( getDataType(1) ); // param is no object typealert( getDataType(true) ); // param is no object typealert( getDataType('a') ); // param is no object type instanceof1234567var o = &#123; 'name':'lee' &#125;;var a = ['reg','blue']; alert( a instanceof Array ); // truealert( o instanceof Array ); // falsealert( a instanceof Object ); // truealert( o instanceof Object ); // true instanceof 多个iframe下12345678var iframe = document.createElement('iframe');document.body.appendChild(iframe);xArray = window.frames[window.frames.length-1].Array;var arr = new xArray(1,2,3); // [1,2,3]// Correctly checking for ArrayArray.isArray(arr); // true// Considered harmful, because doesn't work through iframesarr instanceof Array; // false Array.isArray() （IE9以及上支持）1234567891011121314151617// all following calls return trueArray.isArray([]);Array.isArray([1]);Array.isArray(new Array());// Little known fact: Array.prototype itself is an array:Array.isArray(Array.prototype); // all following calls return falseArray.isArray();Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(17);Array.isArray('Array');Array.isArray(true);Array.isArray(false);Array.isArray(&#123; __proto__: Array.prototype &#125;); ECMAScript5中Array.isArray是原生的判断数组的方法，IE9及以上支持。考虑到兼容性，在没有此方法的浏览器中，可以使用Object.prototype.toString.call(obj) === ‘[object Array]’替代。12345var isArray = Array.isArray || function(obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]';&#125; var arr = [];console.log(isArray(arr)) // true Array 对象方法 concat() join() slice() splice() push() pop() shift() unshift() concat()方法concat()方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。concat方法创建一个新的数组，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（如果参数是数组）或参数本身（如果参数不是数组）。它不会递归到嵌套数组参数中。 concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中，如下所示： 对象引用（而不是实际对象）：concat将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。数据类型如字符串，数字和布尔（不是String，Number 和 Boolean 对象）：concat将字符串和数字的值复制到新数组中。 数组/值在连接时保持不变。此外，对于新数组的任何操作（仅当元素不是对象引用时）都不会对原始数组产生影响，反之亦然。 concat()例子连接两个数组 以下代码将两个数组合并为一个新数组：12345678910111213141516171819202122var alpha = ['a', 'b', 'c'];var numeric = [1, 2, 3];alpha.concat(numeric);// result in ['a', 'b', 'c', 1, 2, 3]//合并嵌套数组以下代码合并数组并保留引用：var num1 = [[1]];var num2 = [2, [3]];var nums = num1.concat(num2);console.log(nums);// results in [[1], 2, [3]]// modify the first element of num1num1[0].push(4);console.log(nums);// results in [[1, 4], 2, [3]] join()方法join() 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。不改变原始数组，而是返回新的字符串12345678str = arr.join()// 默认为 \",\"str = arr.join(\"\")// 分隔符 === 空字符串 \"\"str = arr.join(separator)// 分隔符 separator 指定一个字符串来分隔数组的每个元素。 如果需要(separator)，将分隔符转换为字符串。 如果省略分隔符参数，数组元素用逗号分隔。默认为 “,”。 如果separator是空字符串(“”)，则所有元素之间都没有任何字符。 返回值一个所有数组元素连接的字符串。如果 arr.length 为0，则返回空字符串 拓展延伸数组contact()方法并不能递归到嵌套数组，可以通过join()方法将数组转换成字符串，然后通过split()方法将字符串输出为数组12345var num1 = [[1]];var num2 = [2, [3],[[[7],9],8]];var nums = num1.concat(num2).join().split();// [1,2,3,7,9,8] slice()方法slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。且原始数组不会被修改。1arrayObject.slice(start,end) 返回值返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 begin 可选 从该索引处开始提取原数组中的元素（从0开始）。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin，则 slice 从索引 0 开始。 end可选 在该索引处结束提取原数组元素（从0开始）。slice会提取原数组中索引从 begin 到 end 的所有元素（包含begin，但不包含end）。slice(1,4) 提取原数组中的第二个元素开始直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1)表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。如果 end 被省略，则slice 会一直提取到原数组末尾。如果 end 大于数组长度，slice 也会一直提取到原数组末尾。 splice()方法1arrayObject.splice(index,howmany,item1,.....,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1,item2,itemX 可选。向数组添加的新项目。 返回值返回包含被删除项目的新数组，如果有的话。 请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 push/pop/shift/unshift 方法 说明 返回值 是否改变原数组 push 向数组的末尾添加一个或多个元素， 新的 length 属性值 是 pop 数组中删除最后一个元素 该元素的值(当数组为空时返回undefined) 是 shift 从数组中删除第一个元素 该元素的值(当数组为空时返回undefined) 是 unshift 将一个或多个元素添加到数组的开头 新的 length 属性值 是 push()1234567891011121314var obj = &#123; length: 0, addElem: function addElem (elem) &#123; // obj.length is automatically incremented // every time an element is added. [].push.call(this, elem); &#125;&#125;;// Let's add some empty objects just to illustrate.obj.addElem(&#123;&#125;);obj.addElem(&#123;&#125;);console.log(obj.length);// → 2 reverse() 用于颠倒数组中元素的顺序。 该方法会直接修改原数组，而不会创建新数组。 sort() 用于对数组的元素进行排序。 该排序直接修改原数组，不生成副本。 该方法接受一个可选参数，若未使用参数，将按字母顺序对数组元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。*如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 12345678910function compare(a, b) &#123;if (a &lt; b ) &#123; // 按某种排序标准进行比较, a 小于 b return -1;&#125;if (a &gt; b ) &#123; return 1;&#125;// a must be equal to breturn 0;&#125; 要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列123function compareNumbers(a, b) &#123; return a - b; // 由小到大&#125; String类型常用原生方法 concat() slice() substring() substr() split() 方法 说明 返回对象 concat 连接字符串 新的字符串（字符串连接，实际情况中用+号更加方便） slice 分割提取字符串 新的字符串 substring 分割提取字符串 新的字符串 substr 分割提取字符串 新的字符串 split 分割成字符串数组 一个字符串数组 例子1var str=''hello world; 只有一个参数(正值) 返回值 说明 str.slice(3) // lo world 返回从位置3到原字符串结尾的字符串 str.substring(3) 同上 同上 str.substr(3) 同上 同上 只有一个参数(负值) 返回值 说明 str.slice(-3) // rld 将负值加上数组长度 等同于str.splice(8) str.substring(-3) // hello world 不接受负参数 等同于 str.substring(0) str.substr(-3) // rld 将第一个负值加上数组长度 等同于str.substr(8) 两个参数 返回值 说明 str.slice(3,7) // lo w 返回原字符串从位置3到7（包括3但是不包括7）之间的字符串 str.substring(3,7) // lo w 返回原字符串从位置3到7（包括3但是不包括7）之间的字符串 str.substr(3,7) // lo worl 第二个参数代表返回的字符串个数为7个 两个参数 返回值 说明 str.slice(3,2) 空 都为正值的情况下，第二个参数小于第一个参数即结束位置小于开始位置 无返回值 str.substring(3,2) // l 开始位置小于结束位置，将自动调整为 str.substring(2,3) str.substr(3,2) // lo 第二个参数代表返回的字符串个数为2个 两个参数 返回值 说明 str.slice(3,-4) // lo w 将负值加上数组长度 等同于substr(3,7) str.substring(3,-4) // hel 不接受负参数 等同于 str.substring(3,0) 开始位置小于结束位置，将自动调整为 str.substring(0,3) str.substr(3,-4) 无 第二个参数不接受负参数 代表返回的字符串个数为0个 两个参数 返回值 说明 str.slice(-4,-3) // o 将负值加上数组长度 等同于substr(7,8) str.substring(-4,-3) 无 不接受负参数 等同于 str.substring(0,0) str.substr(-4,-3) 无 第二个参数不接受负参数 代表返回的字符串个数为0个 split() 方法split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。1str.split([separator[, limit]]) separator指定表示每个拆分应发生的点的字符串。separator 可以是一个字符串或正则表达式。 如果纯文本分隔符包含多个字符，则必须找到整个字符串来表示分割点。如果在str中省略或不出现分隔符，则返回的数组包含一个由整个字符串组成的元素。如果分隔符为空字符串，则将str原字符串中每个字符的数组形式返回。 limit一个整数，限定返回的分割片段数量。当提供此参数时，split 方法会在指定分隔符的每次出现时分割该字符串，但在限制条目已放入数组时停止。如果在达到指定限制之前达到字符串的末尾，它可能仍然包含少于限制的条目。新数组中不返回剩下的文本。 split()实例1234var colorText = \"color:white,red,\\\\xx\\\\y\";console.log(colorText.split(/[\\\\]+/)); // [\"color:white,red,\", \"xx\", \"y\"]console.log(colorText.split(/[^\\,]+/)); // [\"\", \",\", \",\", \"\"]console.log(colorText.split(',',2)); // [\"color:white\", \"red\"] 已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById” 12345678910// 方法一function combo(msg) &#123; var arr = msg.split(\"-\"); var len = arr.length; //将arr.length存储在一个局部变量可以提高for循环效率 for (var i = 1; i &lt; len; i++) &#123; arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1); &#125; msg = arr.join(\"\"); return msg; &#125; 1234// 方法二foo.replace(/\\-[a-z]/g,function(match)&#123; return match.substring(1).toUpperCase() &#125;); Date类型 Date类型使用UTC（国际协调时间）1970年1月1日午夜（零时)开始经过的毫秒数来保存日期1234new Date(); // 无参数下 Date对象返回当前的日期和时间new Date(value); // 代表自1970年1月1日00:00:00 (世界标准时间) 起经过的毫秒数。new Date(dateString); //表示日期的字符串值。该字符串应该能被 Date.parse() 方法识别new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]); //代表月份的整数值从0（1月）到11（12月）。 Date方法 Date.now() 返回自 1970-1-1 00:00:00 UTC (世界标准时间)至今所经过的毫秒数。 Date.parse() 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。 Date.UTC() 接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。 Date.parse()Date.parse() 方法解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN。 不推荐在ES5之前使用Date.parse方法，因为字符串的解析完全取决于实现。直到至今，不同宿主在如何解析日期字符串上仍存在许多差异，因此最好还是手动解析日期字符串（在需要适应不同格式时库能起到很大帮助）。 显式调用1Date.parse(dateString) 隐式调用1new Date(dateString) Date.UTC()UTC 方法接受以逗号隔开的日期参数，返回1970-1-1 00:00:00 UTC到指定的日期之间的毫秒数。你应该指定一个完整格式的年份，如 1998。如果年份被指定为 0 到 99 之间，则该方法会将年份转换为 20 世纪的一个年份（即 1990 + year），例如，指定为 95， 则年份为 1995。 如果有一个指定的参数超出其合理范围，则 UTC 方法会通过更新其他参数直到该参数在合理范围内。例如，为月份指定 15，则年份将会加 1，然后月份将会使用 3。 时间倒计时实例123456789101112/** * 移动端 new Date() 传入日期参数出来的时间会比当前的时间+8小时 * * */var featureTime = new Date('2018/11/13 13:55:55+0800');var nowTime = new Date();var timeDiff = (featureTime.getTime() - nowTime.getTime()) / 1000;var d = parseInt(timeDiff / 86400); // 一天24小时 一小时60分 一分钟60秒 合计86400 秒var h = parseInt((timeDiff % 86400 ) / 3600) // 剩余小时var m = parseInt((timeDiff % 86400 ) % 3600 / 60) //剩余分钟var s = parseInt( timeDiff % 60) //剩余秒console.log(d + '天' + h + '小时' + m + '分钟' + s + '秒')","tags":[{"name":"js","slug":"js","permalink":"https://liuchao0704.github.io/tags/js/"}]},{"title":"angular1开发webApp | 持续更新","date":"2017-07-07T13:45:43.000Z","path":"2017/07/07/angularApp/","text":"最近用angular做了一些webApp,也总结了不少的固定套路。现在将固定套路整理如下,主要分为css,js,插件三部分。 js部分利用$rootscope打造轻量级数据管理 建议将常量定义在 main.js 里的 $rootscope里,必要时结合$localstorage 使用。好处:一次定义,多次复用，实时更新 1234567891011121314151617181920212223var u = navigator.userAgent; $scope.app = &#123; errorId:null, //错误码 enableToAddEquip: false, //是否可以添加设备 environment: /localhost/.test(window.location.href) ? 'dev' : 'product', //开发or生产环境 logOut: false, //是否退出 isAndroid: u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1 || u.indexOf('Linux') &gt; -1, //判断安卓或者苹果 isIphone: u.indexOf('iPhone') &gt; -1, version: 1.0, weatherKey: 5, //天气状态码 roleName: $localStorage.app ? $localStorage.app.roleName : '', // 不在提示绑定 email: $localStorage.app ? $localStorage.app.email : '', // 终端用户 &amp; 安装商email userName: $localStorage.app ? $localStorage.app.userName : '', password: $localStorage.app ? $localStorage.password : '', installerSn: $localStorage.app ? $localStorage.app.installerSn : null, operationSn: $localStorage.app ? $localStorage.app.operationSn : null, userSn: $localStorage.app ? $localStorage.app.userSn : null, equipSn: $localStorage.app ? $localStorage.app.equipSn : null, stationId: $localStorage.app ? $localStorage.app.stationId : null, authError: null, successReturnCode: '0000' &#125;; 尝试其他方法和后台做数据交互这个问题是我在做第一个app中遇到的，如果不用ajax，前端有什么其他方法和后台做数据交互？我的partner提出了一个可行的方法。大致思路是后端拦截前端所有页面间的跳转，前端不主动跳转页面。所有的跳转由后台协助完成。在android系统里前、后端约定好一个函数名称，如果前端调用该函数，函数的参数即是需要交互的数据。后端通过参数获取前端上传的数据。并将前端需要的结果以字符串的形式返回（可以是url，也可以是解析后的JSON字符串） var url = window.jsOjb.login(&apos;demo&apos;,&apos;123456&apos;) // demo 用户名 123456 密码 函数的返回值即成功登陆之后的url链接 if(url){ window.location.href = url; } 在ios系统中稍微不一样 var url = window.location.href = ‘,login,name,123456’; CSS部分rem 解决页面适配问题rem 的原理就是根据html的font-size 大小，做到页面的元素宽/高度自适应。而用rem遇到的问题是：如果用js动态设置页面的font-size，页面会有一瞬间的先缩小后放大过程。我的解决方案是利用css3的媒体查询直接改变html的font-size大小。此段代码可以写在页面重置css里 12345678html&#123;font-size:32px !important;&#125;@media screen and (min-width:350px) and (max-width:374px)&#123;html&#123;font-size:35px !important;&#125;&#125;@media screen and (min-width:375px) and (max-width:413px)&#123;html&#123;font-size:37px!important;&#125;&#125;@media screen and (min-width:414px) and (max-width:639px)&#123;html&#123;font-size:41px!important;&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:64px!important;&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:72px!important;&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:75px!important;&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:80px&#125;&#125; html 部分的meta标签 123&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt; &lt;!-- ios自动识别数字为电话号码导致页面错位 --&gt;&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; input[typr=radio]表现怪异由于重置了一些css样式导致input输入框的样式变成可以复制粘贴，而不是呈点击状态故将css代码贴出来，防止再入坑12/* 此代码会导致input单选框怪异模式*/ input:-webkit-user-modify:read-write-plaintext-only; [sticky footer 布局]点击查看 App单页面切换效果SPA加上页面切换效果堪比原生App点击查看","tags":[{"name":"angular","slug":"angular","permalink":"https://liuchao0704.github.io/tags/angular/"},{"name":"webApp","slug":"webApp","permalink":"https://liuchao0704.github.io/tags/webApp/"}]},{"title":"Vue 开发 SPA","date":"2017-07-01T06:57:05.000Z","path":"2017/07/01/vueApp/","text":"用 vue-cli框架搭建一款SPA(参考妙味视频) 全局安装 vue-cli(只需一次安装)1$ npm install -g vue-cli webpack模板搭建1$ vue init webpack my-project 安装 &amp; 启动12$ npm install$ npm run dev 用webstrom 命令行代替每次手动输入 stylus-loader 的安装 这是css的预处理插件，慕课网上的视频安装方法对我本人不管用，具体报错是up to date于是网上各种搜索，找到一款还算靠谱的方案在package.json文件中写入依赖： 12\"stylus-loader\": \"^2.5.0\",\"stylus\": \"0.52.4\", 然后执行命令 12$ npm i stylus-loader stylus --save$ npm run dev 同理安装路由也是(说明：为了和视频一样，我一开始没有选择安装路由，到后面自己安装的，不过现在的vue-cli已经可以在初始化安装的时候提醒你是否选择安装router 直接选择yes 即可) 1\"vue-router\": \"^2.7.0\" 1$ npm i vue-router --save 套路安装vue-resource 1\"vue-router\": \"^2.7.0\" 1$ npm i vue-resource --save","tags":[{"name":"js","slug":"js","permalink":"https://liuchao0704.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://liuchao0704.github.io/tags/vue/"}]},{"title":"Angular $on、$emit、$broadcast 事件传播时机分析","date":"2017-05-17T13:43:51.000Z","path":"2017/05/17/broadcast/","text":"小小的总结 事件传播的时机分析 事件传播的格式和用法比较简单。而对于事件传播的时机有可以分析的地方。其中js的执行顺序是先执行父级controller，再执行子级controller，所以当父级发出事件的时候，子级有可能接收不到事件。 12345678910111213141516171819202122232425262728293031323334353637var app = angular.module('myApp', []);app.controller('ParentCtrlrl', function($scope, $http) &#123; // 父级接收事件 $scope.$on('to-parent', function(e, data) &#123; console.log(data) &#125;); //父级直接传播事件1 $scope.$broadcast('to-child', 'x'); //父级异步传播事件2 $http.post('api.json').then(function(res) &#123; if (res.data.success) &#123; $scope.$broadcast('to-child', 'y'); &#125; &#125;) //父级点击传播事件3 $scope.click = function() &#123; $scope.$broadcast('to-child', 'z'); &#125;&#125;);app.controller('SelfCtrl', function($scope) &#123; // 子级直接传播事件1 $scope.$emit('to-parent', '1'); // 子级接收事件2 $scope.$on('to-child', function(e, data) &#123; console.log(data) &#125;);&#125;); 看一下打印结果 1231yz //点击之后出现z,而x始终未出现 思考父级controller如何在子级js执行后传播事件？我的思路是：增加一个子级向上通知的事件。子级先向父级传播事件 →父级接收到事件后 → 父级向下传播事件 → 子级接收事件 1234567891011121314151617181920212223 var app = angular.module('myApp', []); app.controller('ParentCtrlrl', function($scope, $http) &#123; // 父级接收事件之后再传播 $scope.$on('to-parent', function(e, data) &#123; console.log(data); $scope.$broadcast('to-child', 'x'); &#125;);&#125;);app.controller('SelfCtrl', function($scope) &#123; // 子级接收事件2 $scope.$on('to-child', function(e, data) &#123; console.log(data) &#125;); // 子级直接传播事件1 $scope.$emit('to-parent', '1');&#125;); 查看一下打印结果 121X","tags":[{"name":"angular","slug":"angular","permalink":"https://liuchao0704.github.io/tags/angular/"}]},{"title":"Select与Datepicker插件控制日期","date":"2017-04-23T06:57:33.000Z","path":"2017/04/23/datepicker/","text":"Date对象和Datepicker插件使用总结 datepicker 基本用法 123456&lt;div class=\"input-group date\" id=\"date\" data-provide=\"datepicker\"&gt; &lt;input type=\"text\" class=\"form-control\" readonly=\"readonly\" ng-disabled=\"disable\"&gt; &lt;div class=\"input-group-addon\"&gt; &lt;span class=\"glyphicon glyphicon-th\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345$(&apos;#date&apos;).datepicker(&#123; language: &apos;zh-CN&apos;, autoclose: true, format: &apos;yyyy-mm-dd&apos;&#125;); 直接将日期更新到今日 1$('#date').datepicker('update', new Date()) // 日期更新到今日 Select 改变日期预览格式 支持日/月/年视图切换 月视图写法 12345678 $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, startView: 1, maxViewMode: 1, minViewMode: 1, format: 'yyyy-mm'&#125;); 点击前后按钮实现日期自动+1/-1切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;!doctype html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;日期联动&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;!--datepicker css --&gt; &lt;link rel=\"stylesheet\" href=\"dist/css/bootstrap-datepicker.css\"&gt; &lt;script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt; &lt;/script&gt; &lt;script src=\"angular-1.3.0.js\"&gt;&lt;/script&gt; &lt;!--datepicker js --&gt; &lt;script src=\"dist/js/bootstrap-datepicker.js\"&gt;&lt;/script&gt; &lt;!--datepicker language js --&gt; &lt;script src=\"dist/locales/bootstrap-datepicker.zh-CN.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" ng-controller=\"myCtrl\"&gt; &lt;h4 class=\"col-xs-12\"&gt; Select与Datepicker插件控制日期&lt;/h4&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-5\" class=\"form-group\"&gt; &lt;select name=\"dateType\" class=\"form-control\" ng-model=\"dateType\" ng-change=\"dateTypeChange(dateType)\"&gt; &lt;option value=\"1\"&gt;日&lt;/option&gt; &lt;option value=\"2\"&gt;月&lt;/option&gt; &lt;option value=\"3\"&gt;年&lt;/option&gt; &lt;option value=\"4\"&gt;总&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"col-xs-1\" ng-click=\"gotoPreNext(0)\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-left\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"col-xs-5\"&gt; &lt;div class=\"input-group date\" id=\"date\" data-provide=\"datepicker\"&gt; &lt;input type=\"text\" class=\"form-control\" readonly=\"readonly\" ng-disabled=\"disable\"&gt; &lt;div class=\"input-group-addon\"&gt; &lt;span class=\"glyphicon glyphicon-th\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-xs-1\" ng-click=\"gotoPreNext(1)\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-rightglyphicon glyphicon-\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.dateType = '1'; // 初始化默认日期类型为日; // 为Date 添加format方法 Date.prototype.format = function(fmt) &#123; var o = &#123; \"M+\": this.getMonth() + 1, //月份 \"d+\": this.getDate(), //日 \"h+\": this.getHours(), //小时 \"m+\": this.getMinutes(), //分 \"s+\": this.getSeconds(), //秒 \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \"S\": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); &#125; for (var k in o) &#123; if (new RegExp(\"(\" + k + \")\").test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); &#125; &#125; return fmt; &#125;; $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, format: 'yyyy-mm-dd' &#125;); $('#date').datepicker('update', new Date()) // 默认当天日期 $scope.disable = false; // 默认可选日期 $scope.dateTypeChange = function(type) &#123; var str = ''; switch (parseInt(type)) &#123; case 1: $scope.disable = false; $('#date').datepicker('remove'); $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, format: 'yyyy-mm-dd' &#125;); $('#date').datepicker('update', new Date()) break; case 2: $scope.disable = false; $('#date').datepicker('remove'); $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, startView: 1, maxViewMode: 1, minViewMode: 1, format: 'yyyy-mm' &#125;); str = new Date().format('yyyy-MM') $('#date').datepicker('update', str) break; case 3: $scope.disable = false; $('#date').datepicker('remove'); $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, startView: 2, maxViewMode: 2, minViewMode: 2, format: 'yyyy' &#125;); str = new Date().format('yyyy') $('#date').datepicker('update', str) break; case 4: $scope.disable = true; $('#date input').val('---'); $('#date').datepicker('remove'); break; default: break; &#125; &#125; // 前后按钮改变日期 前一天 后一天 $scope.gotoPreNext = function(flag)&#123; var curDate = $('#date input').val(); var dateY = parseInt(curDate.split('-')[0])|| parseInt(curDate); // 年比较特殊 不需要分割直接使用 var dateM = parseInt(curDate.split('-')[1])|| 0; var dateD = parseInt(curDate.split('-')[2])|| 0; debugger; switch (parseInt($scope.dateType)) &#123; case 1: if(flag)&#123; $('#date').datepicker('update', new Date(dateY, dateM-1 , dateD + 1)) &#125;else&#123; $('#date').datepicker('update', new Date(dateY, dateM-1 , dateD -1)) &#125; break; case 2: if(flag)&#123; $('#date').datepicker('update', new Date(dateY, dateM, 1)); &#125;else&#123; $('#date').datepicker('update', new Date(dateY, dateM-2, 1)) &#125; break; case 3: if(flag)&#123; $('#date').datepicker('update', new Date(dateY + 1,0,1)) &#125;else&#123; $('#date').datepicker('update', new Date(dateY - 1,0,1)) &#125; break; default: break; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"js","slug":"js","permalink":"https://liuchao0704.github.io/tags/js/"},{"name":"date","slug":"date","permalink":"https://liuchao0704.github.io/tags/date/"}]},{"title":"Angular JS动态控制多选框全选与全不选并且打印选中的值","date":"2017-04-10T12:34:40.000Z","path":"2017/04/10/multiselect/","text":"Angular JS获取多选框处理的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=\"myApp\" ng-controller=\"vipApplyEditCtrl\"&gt; &lt;div&gt; &lt;div ng-repeat=\"color in colors\"&gt; &lt;input type=\"checkbox\" ng-checked=\"isChecked(color.id)\" ng-click=\"updateSelection($event,color.id)\" /&gt;&#123;&#123;color.name&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; Selected : &#123;&#123;selected&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller(\"vipApplyEditCtrl\", function($scope) &#123; $scope.colors = [ &#123;id : 1, name : 'black'&#125;, &#123;id : 2, name : 'red'&#125;, &#123;id : 3, name : 'blue'&#125;, &#123;id : 4, name : 'yellow'&#125;, &#123;id : 5, name : 'green'&#125;, &#123;id : 6, name : 'white'&#125; ] ; $scope.selected = [] ; $scope.isChecked = function(id)&#123; return $scope.selected.indexOf(id) &gt;= 0 ; &#125; ; $scope.updateSelection = function($event,id)&#123; var checkbox = $event.target ; var checked = checkbox.checked ; if(checked)&#123; $scope.selected.push(id) ; &#125;else&#123; var idx = $scope.selected.indexOf(id) ; $scope.selected.splice(idx,1) ; &#125; &#125; ; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过ng-checked 属性选中某个多选框1$scope.selected = [2] ; // 支持预先选中某个选项 增加全选和取消全选的按钮 1、增加一个开关控制单选或者全选(可以用checkbox 或者 radio) 2、动态改变select数组 3、单个选项进行操作的时候判断是否改变了全选或者非全选的状态，如果改变动态更新 4、涉及到checkbox 和 radio 操作请使用ng-change来代替ng-click，否则model值为undefined或者未更新 5、针对第四条补充说明如果是单纯的点击操作，不涉及到model值的传递，可以用ng-click，但是需要将model值作为函数的参数进行传递的时候请使用ng-change比较稳妥。 方案一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"angular-1.3.0.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=\"myApp\" ng-controller=\"vipApplyEditCtrl\"&gt;&lt;div&gt; &lt;input type=\"checkbox\" name=\"all\" ng-model=\"all\" ng-change=\"toSelectAll(all)\"&gt; 全选 &lt;i&gt;&#123;&#123;all&#125;&#125;&lt;/i&gt; &lt;div ng-repeat=\"color in colors\"&gt; &lt;input type=\"checkbox\" ng-checked=\"isChecked(color.id)\" ng-click=\"updateSelection($event,color.id)\" /&gt; &#123;&#123;color.name&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; Selected :&#123;&#123;selected&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller(\"vipApplyEditCtrl\", function($scope) &#123; $scope.formData = &#123;&#125;; $scope.colors = [ &#123;id : 1, name : 'black'&#125;, &#123;id : 2, name : 'red'&#125;, &#123;id : 3, name : 'blue'&#125;, &#123;id : 4, name : 'yellow'&#125;, &#123;id : 5, name : 'green'&#125;, &#123;id : 6, name : 'white'&#125; ] ; $scope.selected = [] ; $scope.isChecked = function(id)&#123; return $scope.selected.indexOf(id) &gt;= 0 ; &#125; ; $scope.updateSelection = function($event,id)&#123; var checkbox = $event.target ; var checked = checkbox.checked ; if(checked)&#123; $scope.selected.push(id); &#125;else&#123; var idx = $scope.selected.indexOf(id) ; $scope.selected.splice(idx,1) ; &#125; if($scope.selected.length == $scope.colors.length) &#123; $scope.all = true; &#125;else&#123; $scope.all = false; &#125; &#125; ; $scope.toSelectAll = function(flag)&#123; if(flag)&#123; $scope.selected = [] angular.forEach($scope.colors, function (i) &#123; $scope.selected.push(i.id); &#125;) &#125;else&#123; angular.forEach($scope.colors, function (i) &#123; $scope.selected = []; &#125;) &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 方法二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script src=\"angular-1.3.0.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=\"myApp\" ng-controller=\"vipApplyEditCtrl\"&gt;&lt;div&gt; &lt;input type=\"checkbox\" name=\"all\" ng-model=\"all\" ng-change=\"toSelectAll(all)\"&gt; 全选 &lt;i&gt;&#123;&#123;all&#125;&#125;&lt;/i&gt; &lt;div ng-repeat=\"color in colors\"&gt; &lt;input type=\"checkbox\" ng-checked=\"color.checked == true\" ng-click=\"updateSelection(color)\" /&gt; &#123;&#123;color.name&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div&gt; Selected :&#123;&#123;selected&#125;&#125;&lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller(\"vipApplyEditCtrl\", function($scope) &#123; $scope.formData = &#123;&#125;; $scope.colors = [ &#123;id : 1, name : 'black'&#125;, &#123;id : 2, name : 'red'&#125;, &#123;id : 3, name : 'blue'&#125;, &#123;id : 4, name : 'yellow'&#125;, &#123;id : 5, name : 'green'&#125;, &#123;id : 6, name : 'white'&#125; ] ; $scope.selected = [] ; $scope.updateSelection = function(obj)&#123; if(!obj.checked )&#123; obj.checked = true; $scope.selected.push(obj.id); &#125;else&#123; obj.checked = false; var idx = $scope.selected.indexOf(obj.id) ; $scope.selected.splice(idx,1) ; &#125; if($scope.selected.length == $scope.colors.length) &#123; $scope.all = true; &#125;else&#123; $scope.all = false; &#125; &#125; ; $scope.toSelectAll = function(flag)&#123; if(flag)&#123; $scope.selected = [] angular.forEach($scope.colors, function (i) &#123; i.checked = true; $scope.selected.push(i.id); &#125;) &#125;else&#123; angular.forEach($scope.colors, function (i) &#123; i.checked = false; $scope.selected = []; &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"angular","slug":"angular","permalink":"https://liuchao0704.github.io/tags/angular/"},{"name":"js","slug":"js","permalink":"https://liuchao0704.github.io/tags/js/"},{"name":"checkbox","slug":"checkbox","permalink":"https://liuchao0704.github.io/tags/checkbox/"}]},{"title":"简约黑白风改造清爽一居室 | 更新","date":"2017-03-29T12:09:50.000Z","path":"2017/03/29/direction/","text":"40平老破小出租房变身清爽一居室。由于本人资金匮乏加上半个颜控，还要面对顽固的反对派，所以这注定是一个不太完美并且艰辛的装修之旅。 写在前面装修之前参考了一兜糖的TTTTTT的案例，觉得特别给力，无论是面积和风格都无一不击中我的少女心。后来在某群里偶遇TTTTTT本人才知道对方是资深装修达人，哦，对了忘记插一句关于TTTTTT是美少女的人设也只是我的一厢情愿而已，其实T总是超级暖男！！！回归正题，二手房装修特别是房龄长的二手房改造其实很费神费力。 2018-05更新(Blackdoor) 毕业照 计划17年5月份开始动工的，选择全包，本人工作繁忙，所有东西能网购解决的绝对不出门半步。也属于无人监工状态，很多地方都只能选择睁只眼闭只眼。如果有下次装修，还是要留人盯着看，工期和质量各方面都有保证。 第一版设计图1、封闭式厨房U型设计，含冰箱2、书房餐厅功能合并，增加干区洗面台，干湿分离3、卫生间去掉浴缸改为淋浴4、阳台放置洗衣机满足生活阳台功能5、第一版水电点位确定 区域 明细 个数 明细 厨房 双控开关 1对 玄关口1个，靠近卧室门口1个，用于厨房主照明代替玄关照明？ 厨房 五孔插座 1个 距地1.8m，灶台上方，预留给抽烟机 厨房 带开关五孔插座 3个 避开灶台和水槽，电饭煲，热水壶，微波炉 厨房 五孔插座 1个 燃气热水器 厨房 五孔插座 1个 冰箱侧后方冰箱用 厨房 五孔插座 2个 预留给净水器和垃圾处理器 卫生间 集成式浴霸开关 1个 可以控制风暖排气照明 卫生间 防水盖五孔插座 1个 预留给智能马桶，提前知道马桶尺寸 卫生间 开关 1个 照明 餐厅 开关 1个 餐厅主照明 餐厅 五孔插座 1个 火锅、电磁炉 、手机充电 餐厅 五孔插座 1个 预留空气净化器或者吸尘器 餐厅 16A三孔插座 1个 空调挂机 餐厅-洗面台 开关 1个 照明筒灯 卧室 双控开关 1对 控制卧室主照明 卧室 四孔插座 2个 台灯、手机充电用 床头一侧分布2个 卧室 五孔插座 2个 书桌上面 笔记本用，台灯用 卧室 五孔插座 2个 书桌下面 预留 卧室 16A三孔插座 1个 空调挂机 卧室 五孔插座 1个 预留空气净化器或者吸尘器 阳台家务 开关 1个 阳台主照明 阳台家务 防水盖五孔插座 1个 洗衣机 第二版修改1、封闭式厨房L型设计，去掉部分上下柜2、餐厅增加干区洗面台+防水吊顶3、衣柜+射灯控制（仿衣帽间）4、第二版水电点位确定 区域 明细 个数 明细 玄关 双控开关 1对 对角线分布控制玄关主照明 玄关 五孔插座 2个 距地30cm，路由器小夜灯(厨房正对面) 厨房 双控开关 1对 对角线布置，用于厨房主照明(可以和玄关布置在一起) 厨房 五孔插座 1个 距地1.8m，灶台上方，预留给抽烟机 厨房 带开关五孔插座 3个 避开灶台和水槽，电饭煲，热水壶，微波炉 厨房 五孔插座 1个 燃气热水器 厨房 五孔插座 1个 距地30cm，冰箱侧后方冰箱用 厨房 五孔插座 2个 水槽下方预留给净水器和垃圾处理器 卫生间 集成式浴霸开关 1个 可以控制风暖排气照明 卫生间 防水盖五孔插座 1个 预留给智能马桶，提前知道马桶尺寸 卫生间 开关 1个 卫生间照明 餐厅 开关 1个 餐厅主照明 餐厅 五孔插座 2个 火锅、电磁炉 、手机充电、笔记本电脑 餐厅 五孔插座 1个 餐厅另一面墙预留空气净化器或者吸尘器 餐厅 16A三孔插座 1个 预留给空调挂机 餐厅-洗面台 开关 1个 镜前灯 餐厅-洗面台 五孔插座 1个 吹风机，电动牙刷 餐厅-洗面台 五孔插座 1个 小厨宝 卧室 双控开关 1对 控制卧室主照明 卧室 开关 1个 控制衣柜上方轨道射灯照明 卧室 五孔插座 2个 床头柜上方台灯、手机充电用 卧室 五孔插座 2个 书桌上面 笔记本用，台灯用 卧室 五孔插座 2个 书桌下面 预留 卧室 16A三孔插座 1个 距地2.0米空调挂机 卧室 五孔插座 3个 有限电视/挂烫机/吸尘器/空气净化器用 阳台家务 开关 1个 阳台主照明 阳台家务 防水盖五孔插座 1个 洗衣机 厨房装修可以说厨房和卫生间的瓷砖风格直接决定了我所有的装修风格。因为一眼看中了 清爽的小白砖(尺寸300*300)，所以定下了主色调白色+黑色，地砖用的灰色也算低调。厨房的水槽也是特意选了黑色。安装这个水槽的时候也是破费周折。下水口的直径是非标的(口径58mm)用不上潜水艇的防臭下水管(潜水艇适合45/56)，我买了又退，不过不得不说潜水艇的质量真心好。之后上某宝买了转接口(内58转外45)和超长下水管。 安装好小米净水器的时候，发现排污口无处安放。幸好有万能的某宝，在溢水口处做了文章，分出一个口给净水器排污口。 在实际使用过程中遭遇了老房子的坑，下水水流过慢过大容易漏水。我暂时用玻璃胶处理了，但是并不是很完美的方法。 厨房其他的东西都是中规中矩了。 卫生间篇卫生间是老房子通病，面积小的可怜不到2平米。管道外露直接影响吊顶之后的高度，马桶位移又抬高地面。卫生间绝对是最难搞且不是很满意的地方。由于面积小只安排了淋浴和马桶。将台盆移到了外面，洗衣机移到了阳台。这样勉强让卫生间的空间合理了，也做了个干湿分离。 餐厅篇餐厅由于做了干区洗面台，留下的空间就一张餐桌了。餐厅朝南采光挺好，原本计划是餐厅和办公用。小窗户选了百叶窗又能节省空间，可以在窗边安装个书架放放东西和书本 餐桌不能选太大的，折叠的就很好 ​ 卧室篇卧室面积最大，订做了一个衣柜，主要不想给顶部留空间，但是做完发现怪怪的甚至有点丑，以后衣柜还是考虑成品。书桌和铁艺床都是干干净净的感觉。减去一个床头柜给卧室留下了个空间。带盖脏衣篮很方便懒人可以随时移动 ，盖上盖子假装脏衣服都消失了。","tags":[{"name":"生活","slug":"生活","permalink":"https://liuchao0704.github.io/tags/生活/"}]},{"title":"ng-repeat下ng-model与对象拷贝的简单分析","date":"2017-03-09T12:27:36.000Z","path":"2017/03/09/ngRepeat/","text":"ng-model绑定到$parent上1234567&lt;ul &gt; &lt;h1 ng-bind=\"radio\"&gt;&lt;/h1&gt; &lt;li ng-repeat=\"x in records\"&gt; &lt;input type=\"radio\" name=\"radio\" ng-model=\"radio\" value=\"&#123;&#123;x&#125;&#125;\"&gt; &lt;label ng-bind=\"x\"&gt;&lt;/label&gt; &lt;/li&gt;&lt;/ul&gt; 当我们选中单选框的时候发现并没有想预期一样显示ng-model的值。这是因为处在ng-repeat之间的代码，对全局的$scope里变量的内容是不可见的，像不是全局$scope里的成员。而是为ng-repeat创建的子scope里面的。所以要引用全局$scope里的成员，你可以使用$parent来引用全局的$scope,修改如下。 12&lt;h1 ng-bind=\"radio\"&gt;&lt;/h1&gt;&lt;input type=\"radio\" name=\"radio\" ng-model=\"$parent.radio\" value=\"&#123;&#123;x&#125;&#125;\"&gt; 这次点击input单选框，绑定的值就能显示了。 ng-model绑定到对象的属性上这次我们将ng-model 绑定到对象上的属性下面，此时不用$parent 也能显示ng-model了1234567&lt;ul &gt; &lt;h1 ng-bind=\"radio2.radio\"&gt;&lt;/h1&gt; &lt;li ng-repeat=\"x in records\"&gt; &lt;input type=\"radio\" name=\"radio2\" ng-model=\"radio2.radio\" value=\"&#123;&#123;x&#125;&#125;\"&gt; &lt;label ng-bind=\"x\"&gt;&lt;/label&gt; &lt;/li&gt;&lt;/ul&gt; 原理分析根据js对象是属于引用类型的特点来将值绑定在对象的属性上，实现了自动更新。 angular下的对象拷贝1angular.copy(source, [destination]); 复制一个对象或者一个数组（好吧，万物皆对象，数组也是一个对象）。 如果省略了destination，一个新的对象或数组将会被创建出来; 如果提供了destination，则source对象中的所有元素和属性都会被复制到destination中 如果source不是对象或数组（例如是null或undefined）, 则返回source; 如果source和destination类型不一致，则会抛出异常。 注意：这个是单纯复制覆盖，不是类似继承。","tags":[{"name":"angular","slug":"angular","permalink":"https://liuchao0704.github.io/tags/angular/"},{"name":"对象","slug":"对象","permalink":"https://liuchao0704.github.io/tags/对象/"}]},{"title":"Angular 表单验证","date":"2017-02-28T14:02:20.000Z","path":"2017/02/28/form/","text":"form表单提交之前的验证操作以及对form表单中单选框和多选框的值获取 Form 表单的状态 属性类 描述 $valid ng-valid Boolean 告诉我们这一项当前基于你设定的规则是否验证通过 $invalid ng-invalid Boolean 告诉我们这一项当前基于你设定的规则是否验证未通过 $pristine ng-pristine Boolean 如果表单或者输入框没有使用则为True $dirty ng-dirty Boolean 如果表单或者输入框有使用到则为True 设置Form表单如果我们使用 novalidate 将不使用html5的表单验证而是使用我们自己的验证注意我们把表单提交事件绑定到form的ng-submit上并且判断表单是否合法userForm.$valid 12345 &lt;form name=\"useform\" novalidate autocomplete=\"off\" ng-submit=\"userForm.$valid &amp;&amp; submitForm()\"&gt;&lt;!-- form 表单一定要有name属性 通过name属性访问表单 input也是如此 同时关闭表单自动填充以及h5 浏览器自带验证方法 --&gt; 当表单不合法禁用提交按钮1&lt;button type=\"submit\" class=\"btn btn-danger m-t\" ng-disabled=\"useform.$invalid\"&gt;提交!&lt;/button&gt; 重置表单 (清除$dirty样式)12$scope.menuForm.$setPristine(); $scope.menuForm.$setUntouched(); input 必填/最长/最短/正则匹配123456789101112&lt;div class=\"form-group\" &gt; &lt;label&gt;Name&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" name=\"name\" ng-required=\"true\" ng-model=\"formData.name\" ng-minlength=\"3\" ng-maxlength=\"8\" ng-pattern=\"/^[a-zA-Z]+$/\" &gt;&lt;/div&gt; 使用ng-show来显示错误信息12345678910&lt;div ng-show=\"useform.name.$dirty &amp;&amp; useform.name.$invalid\"&gt; &lt;p ng-show=\"useform.name.$error.minlength\" class=\"help-block\"&gt; 名字太短.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.maxlength\" class=\"help-block\"&gt; 名字太长.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.required\" class=\"help-block\"&gt; 名字是必填的.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.pattern\" class=\"help-block\"&gt; 名字只能是字母.&lt;/p&gt;&lt;/div&gt; 使用ng-class 给表单添加错误样式因为我们使用了 Bootstrap, 我们将就使用它们提供的类(has-error). 这样就能围绕我们的form-group获得漂亮的错误信息和颜色. 12&lt;div class=\"form-group\" ng-class=\"&#123;'has-error':useform.name.$dirty &amp;&amp; (useform.name.$invalid || useform.$submitted)&#125;\"&gt;&lt;/div&gt; input[checkbox] 多选框12345678910111213&lt;!-- MULTIPLE CHECKBOXES --&gt;&lt;label&gt;Favorite Colors&lt;/label&gt;&lt;div class=\"form-group\"&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.red\"&gt; Red &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.blue\"&gt; Blue &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.green\"&gt; Green &lt;/label&gt;&lt;/div&gt; 当选择多选框的时候把formData.favoriteColors打印出来 1\"favoriteColors\":&#123;\"red\":true,\"blue\":true,\"green\":true&#125;&#125; input[checkbox] 添加 value 属性如果我们不想简单的设置checkoxs上ng-model为true或者false,而是希望ng-model能和checkbox 上的value绑定，那该如何绑定呢？ 1&lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.red\" value=\"red\"&gt; Red 我在 vaule上尝试写了个值,打印输出一下看看,结果还是true、false切换并没有达到我们想要的效果，看来checkbox的值绑定需要用到其他方法。 1\"favoriteColors\":&#123;\"red\":true,\"blue\":true,\"green\":true&#125; 原因是当未设置ngTrueValue和ngFalseValue时，checkbox默认值是true和false。如果给checkbox 赋ngTrueValue和ngFalseValue值,那么就能使用我们自定义的值了。请注意字符串添加单引号否则会报错 123456789101112&lt;!-- CUSTOM VALUE CHECKBOXES --&gt;&lt;label&gt;Personal Question&lt;/label&gt;&lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" name=\"awesome\" ng-model=\"formData.awesome\" ng-true-value=\" 'ofCourse'\" ng-false-value=\" 'iWish' \"&gt; Are you awesome? &lt;/label&gt;&lt;/div&gt; 当选择多选框的时候把formData.awesome打印出来 1&#123;\"awesome\":\"ofCourse\"&#125; input[radio] 单选框 value 选择中时的值 ngValue 选择中时的值（表达式） ngchange model更新触发 没有required属性，没办法做必填校验，所以最好初始化的时候默认选中一个。 12345678910111213&lt;label&gt;Chicken or the Egg?&lt;/label&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"chickenEgg\" value=\"chicken\" ng-model=\"formData.chickenEgg\"&gt; Chicken &lt;/label&gt; &lt;/div&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"chickenEgg\" value=\"egg\" ng-model=\"formData.chickenEgg\"&gt; Egg &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; 选中egg把值先打印出来 1\"chickenEgg\":\"egg\" 扩展1：input[radio] 控制 input的 disable 属性场景:如果单选框选择true,则只有true对应的输入框属性可以编辑,如果单选框选择false,则只有false对应的输入框属性可以编辑。 1234div&gt; &lt;input type=\"text\" ng-disabled=\"formData.chickenEgg == 'egg'\" ng-required=\"formData.chickenEgg == 'chicken'\" value=\"chicken\"&gt; &lt;input type=\"text\" ng-disabled=\"formData.chickenEgg == 'chicken'\" ng-required=\"formData.chickenEgg == 'egg'\" value=\"egg\"&gt; &lt;/div&gt; 扩展2：ng-repeat下input[radio]的ng-model详见 https://liuchao0704.github.io/2017/03/09/ngRepeat/ 扩展3：angular动态控制checkbox全选与取消全选详见 https://liuchao0704.github.io/2017/04/10/multiselect/ 下拉框 Select 值是动态生成的123&lt;select ng-model=\"formData.selected\" ng-options=\"x.id as x.name for x in users\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt;&lt;!-- 替换空白--&gt;&lt;/select&gt; 123456789$scope.users = [ &#123;name:'a',id:'1'&#125;, &#123;name:'b',id:'2'&#125;, &#123;name:'c',id:'3'&#125; ];$scope.formData = &#123; selected:'2', chickenEgg:'egg' &#125;; 提交Form表单 123456789101112$scope.submitForm = function()&#123; var param = &#123; name:$scope.formData.name &#125;; $http(&#123; url:'api/test.js', method:'post', data:param &#125;).success(function(data,header,config,status)&#123; &#125;) .error(function(data,header,config,status)&#123;&#125;); &#125;; 点击提交的时候，查看提交头 提交含有文件的Form 表单当form表单中有文件提交的时候，请求设置有些不同，因为是通过anjularjs的http请求来上传文件的，所以要让当前的request成为一个Multipart/form-data请求。 anjularjs对于post和get请求默认的Content-Type header 是application/json。通过设置‘Content-Type’: undefined，这样浏览器不仅帮我们把Content-Type 设置为 multipart/form-data，还填充上当前的boundary，如果你手动设置为： ‘Content-Type’: multipart/form-data，后台会抛出异常：the current request boundary parameter is null。 ps：通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object. 12345678910111213var fd = new FormData();var file1 = document.querySelector('input[name=file]').files[0];fd.append('logo1', file1);$http(&#123; method:\"POST\", url:\"api/test.js\", data:fd, headers:&#123; \"Content-Type\": undefined &#125;, transformRequest: angular.identity &#125;).success(function(data,header,config,status)&#123; &#125;) .error(function(data,header,config,status)&#123;&#125;); ps:上面的file的获取还可以通过：var file = $scope.myFile.同时要注意在js中 data: fd,不能像普通的参数一样写为：params：{ fd，…}，在GET方法中可以使用params ，在POST/PUT/PATCH/DELETE中不能使用params 来传递数据，要使用data来传递。参考：http://blog.csdn.net/wei389083222/article/details/51289704 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link href=\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; &lt;body ng-app=\"formApp\" ng-controller=\"formController\"&gt; &lt;div class=\"col-xs-12 col-sm-10 col-sm-offset-1\"&gt; &lt;h2&gt;Angular Checkboxes and Radio Buttons&lt;/h2&gt; &lt;form name=\"useform\" novalidate autocomplete=\"off\" ng-submit=\"userForm.$valid &amp;&amp; submitForm()\"&gt; &lt;!-- NAME INPUT --&gt; &lt;div class=\"form-group\" ng-class=\"&#123;'has-error':useform.name.$dirty &amp;&amp; useform.name.$invalid&#125;\"&gt; &lt;label&gt;Name&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" name=\"name\" required ng-model=\"formData.name\" ng-minlength=\"3\" ng-maxlength=\"8\" ng-pattern=\"/^[a-zA-Z]+$/\"&gt; &lt;/div&gt; &lt;div ng-show=\"useform.name.$dirty &amp;&amp; useform.name.$invalid\"&gt; &lt;p ng-show=\"useform.name.$error.minlength\" class=\"help-block\"&gt; 名字太短.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.maxlength\" class=\"help-block\"&gt; 名字太长.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.required\" class=\"help-block\"&gt;名字是必填的.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.pattern\" class=\"help-block\"&gt; 名字只能是字母.&lt;/p&gt; &lt;/div&gt; &lt;!-- =============================================== --&gt; &lt;!-- ALL OUR CHECKBOXES AND RADIO BOXES WILL GO HERE --&gt; &lt;!-- =============================================== --&gt; &lt;!-- SUBMIT BUTTON (DOESNT DO ANYTHING) --&gt; &lt;div class=\"col-md-12\" style=\"margin-bottom: 15px;\"&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-danger m-t\" ng-disabled=\"useform.$invalid\"&gt;提交!&lt;/button&gt; &lt;/form&gt; &lt;!-- MULTIPLE CHECKBOXES --&gt; &lt;label&gt;Favorite Colors&lt;/label&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.red\" value=\"red\"&gt; Red &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.blue\" value=\"blue\"&gt; Blue &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.green\" value=\"green\"&gt; Green &lt;/label&gt; &lt;/div&gt; &lt;!-- CUSTOM VALUE CHECKBOXES --&gt; &lt;label&gt;Personal Question&lt;/label&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" name=\"awesome\" ng-model=\"formData.awesome\" ng-checked=\"formData.awesome\" ng-true-value=\" 'ofCourse'\" ng-false-value=\" 'iWish' \"&gt; Are you awesome? &lt;/label&gt; &lt;/div&gt; RADIO BUTTONS &lt;label&gt;Chicken or the Egg?&lt;/label&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"chickenEgg\" value=\"chicken\" ng-model=\"formData.chickenEgg\"&gt; Chicken &lt;/label&gt; &lt;/div&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"chickenEgg\" value=\"egg\" ng-model=\"formData.chickenEgg\"&gt; Egg &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"text\" ng-disabled=\"formData.chickenEgg == 'egg'\" ng-required=\"formData.chickenEgg == 'chicken'\" value=\"chicken\"&gt; &lt;input type=\"text\" ng-disabled=\"formData.chickenEgg == 'chicken'\" ng-required=\"formData.chickenEgg == 'egg'\" value=\"egg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;select ng-model=\"formData.selected\" ng-options=\"x.id as x.name for x in users\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; 替换空白 &lt;/select&gt; &lt;!-- SHOW OFF OUR FORMDATA OBJECT --&gt; &lt;h2&gt;Sample Form Object&lt;/h2&gt; &lt;pre&gt; &#123;&#123; formData &#125;&#125; &lt;/pre&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var formApp = angular.module('formApp', []); formApp.controller('formController', function($scope, $http) &#123; $scope.users = [&#123; name: 'a', id: '1' &#125;, &#123; name: 'b', id: '2' &#125;, &#123; name: 'c', id: '3' &#125;]; // we will store our form data in this object $scope.formData = &#123; selected: '2', chickenEgg: 'egg' &#125;; $scope.submitForm = function() &#123; /* var param = &#123; name:$scope.formData.name &#125;; $http(&#123; url:'api/test.js', method:'post', data:param &#125;).success(function(data,header,config,status)&#123; &#125;) .error(function(data,header,config,status)&#123;&#125;);*/ var fd = new FormData(); var file1 = document.querySelector('input[name=file]').files[0]; fd.append('logo1', file1); $http(&#123; method: \"POST\", url: \"api/test.js\", data: fd, headers: &#123; \"Content-Type\": undefined &#125;, transformRequest: angular.identity &#125;).success(function(data, header, config, status) &#123;&#125;) .error(function(data, header, config, status) &#123;&#125;); &#125;; &#125;); &lt;/script&gt;&lt;/html&gt;","tags":[{"name":"angular","slug":"angular","permalink":"https://liuchao0704.github.io/tags/angular/"},{"name":"form","slug":"form","permalink":"https://liuchao0704.github.io/tags/form/"}]},{"title":"Cookie/localStroage/sessionStorage 本地化存储简单分析比较","date":"2017-02-15T14:07:18.000Z","path":"2017/02/15/cookie/","text":"分析cookie localStroage sessionStorage 之间的特点选择更适合的方式来存储页面之间的交换信息。 Cookie优点：历史悠久,浏览器支持率高。但是cookie在存储空间上有一些限制。 浏览器 cookie个数（每个域名） 单个cookie容量限制 Microsoft 50个 4KB左右(包括name、value和等号) Firefox 50个 4KB左右(包括name、value和等号) Opera 30个 4KB左右(包括name、value和等号) Chrome 53个 4KB左右(包括name、value和等号) Cookie 4 个属性 cookie的生存期属性:expires;默认情况下,cookie只在浏览器会话期存在.退出浏览器就丢失;可以用expires设置时间;退出浏览器后就不会丢失并存为客户端浏览器的cookie文件;过了时间后cookie失效,还会自动删除cookie文件. path属性:默认情况下,在同一个目录下文件可以调用; 例如:http://demo.com/c1/1.html设置的cookie可以被http://demo.com/c1/2.html调用.但不能被http://demo.com/c2/目录下的文件调用; 但如把path属性设成”/“;则在http://demo.com/下的所有文件都可调用此cookie. domain属性:例如设成”.google.com”则在.google.com下的所有服务器下的文件都可以调用cookie 1document.cookie=\"userId=320; path=/\"; 安全属性:默认情况下为false;用http协议不安全传输;true:用https等协议安全传输. 1document.cookie=\"name=value; domain=cookieDomain\"; Cookie 设置123document.cookie = 'username=admin'document.cookie = 'age=17';document.cookie=\"username=admin; age=17\"; //如果是多个键值对： Cookie 函数封装12345678910111213/*添加cookie*/ function addCookie(name, value, days, path) &#123; var name = escape(name); var value = escape(value); var expires = new Date(); expires.setTime(expires.getTime() + days * 3600000 * 24); //path=/，表示cookie能在整个网站下使用，path=/temp，表示cookie只能在temp目录下使用 path = path == \"\" ? \"\" : \";path=\" + path; //GMT(Greenwich Mean Time)是格林尼治平时，现在的标准时间，协调世界时是UTC //参数days只能是数字型 var _expires = (typeof days) == \"string\" ? \"\" : \";expires=\" + expires.toUTCString(); document.cookie = name + \"=\" + value + _expires + path; &#125; 执行一下函数 1addCookie('cookie',222,3); 在本地打开网页会发现Cookie,并且路径是当前文件夹下的路径 Cookie 读取12345678function getCookie(name)&#123;var arr,reg=new RegExp(\"(^| )\"+name+\"=([^;]*)(;|$)\");if(arr=document.cookie.match(reg))return unescape(arr[2]);elsereturn null;&#125; Cookie 删除如果设置的时候 path=&#39;/xxx&#39; 那么删除掉时候也要相应的添加上path 1234567 /*删除cookie*/ function deleteCookie(name,path)&#123; /**根据cookie的键，删除cookie，其实就是设置其失效**/ var name = escape(name); var expires = new Date(0); path = path == \"\" ? \"\" : \";path=\" + path; document.cookie = name + \"=\"+ \";expires=\" + expires.toUTCString() + path;&#125; localStrogelocalStroge 设置1localStorage.setItem(key,value);//设置key 为 value localStroge 获取1localStorage.getItem(key);//获取key的值 localStroge 清除单个Key1localStorage.removeItem(key);//清除key的值 localStroge 清除所有1localStorage.clear();//一次性清除所有的键值对 如果要使cookie在当前整个网站下可用,可以将cookie_dir指定为根目录,例如：1document.cookie=”userid=320;path=/”; localstorage的存储范围就是当前整个网站，不存在指定访问范围这一说。 localStroge遍历存储的数据当你不清楚本地localStorage存储了多少数据的时候，用key(index)方法绝对是一个不错的选择，key方法可以遍历localStorage存储的key。写个简单的例子： 123for(i=0;i&lt;localStorage.length;i++)&#123; document.write(localStorage.key(i)+\":\"+localStorage.getItem(localStorage.key(i))+\"&lt;br/&gt;\");&#125; localStrogeJSON存储当需要存储的数据很多时，可以将数据存储到数组中并转换成JSON格式的数据。 JSON.stringify(data) 将对象转换成JSON格式的数据串。 JSON.parse(data)将数据解析成对象并返回解析后的对象。 这样说或许不太好懂，直接上例子： 123var arr = &#123;\"name\":\"moomoo\",\"age\":2,\"eat\":\"apple\"&#125;;localStorage.setItem(\"arr\",JSON.stringify(arr));arr = JSON.parse(localStorage.getItem(\"arr\")); sessionStorage设置sessionStorage 用法基本同localStroge ,但是当网页关闭重新打开的时候,sessionStorage就会清除。 12345678910sessionStorage(); function sessionStorage() &#123; var arr = &#123; \"name\": \"pp\", \"age\": 33, \"eat\": \"pear\" &#125;; var sessionStorage = window.sessionStorage; // 请注意使用window.sessionStorage 否则会报错 sessionStorage.setItem(\"yy\", JSON.stringify(arr)); &#125; 下面是完整的HMTL代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203 &lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;cookie 跨域和解决方案&lt;/title&gt; &lt;link href=\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"col-xs-12\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 \"&gt; &lt;h2&gt; cookie设置&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"col-xs-12\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 \"&gt; &lt;label for=\"set-cookie-name \" class=\"col-xs-2\"&gt;name&lt;/label&gt; &lt;input type=\"text\" class=\"col-xs-2\" id=\"set-cookie-name\"&gt; &lt;label for=\"set-cookie-value\" class=\"col-xs-2\"&gt;value&lt;/label&gt; &lt;input type=\"text\" class=\"col-xs-2\" id=\"set-cookie-value\"&gt; &lt;button id=\"set-cookie-btn\" type=\"button\" class=\"btn btn-success col-xs-3 col-xs-offset-1 \"&gt; 点击设置cookie &lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-4 \"&gt; &lt;input type=\"text\" class=\"col-xs-5\" id=\"get-cookie-input\"&gt; &lt;button id=\"get-cookie-btn\" class=\" btn btn-info col-xs-5 col-xs-offset-1\"&gt; 获取cookie 按钮&lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-2 \"&gt; &lt;button id=\"del-cookie-btn\" class=\" btn btn-danger col-xs-10 col-xs-offset-1\"&gt; 删除cookie 按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-8 \"&gt; &lt;h2&gt;Localstroge设置&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"col-xs-12\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 \"&gt; &lt;label for=\"set-localstroge-name \" class=\"col-xs-2\"&gt;name&lt;/label&gt; &lt;input type=\"text\" class=\"col-xs-2\" id=\"set-localstroge-name\"&gt; &lt;label for=\"set-localstroge-value\" class=\"col-xs-2\"&gt;value&lt;/label&gt; &lt;input type=\"text\" class=\"col-xs-2\" id=\"set-localstroge-value\"&gt; &lt;button id=\"set-localstroge-btn\" type=\"button\" class=\"btn btn-success col-xs-3 col-xs-offset-1 \"&gt; 点击设置localstroge &lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-4 \"&gt; &lt;input type=\"text\" class=\"col-xs-5\" id=\"get-localstroge-input\"&gt; &lt;button id=\"get-localstroge-btn\" class=\" btn btn-info col-xs-5 col-xs-offset-1\"&gt; 获取localstroge 按钮&lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-2 \"&gt; &lt;button id=\"del-localstroge-btn\" class=\" btn btn-danger col-xs-10 col-xs-offset-1\"&gt; 删除localstroge 按钮&lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-12 \" style='margin-top: 20px;'&gt; &lt;button id=\"del-localstroge-all-btn\" class=\" btn btn-danger col-xs-3 col-xs-offset-2\"&gt; 删除所有localstroge 按钮&lt;/button&gt; &lt;button id=\"set-localstroge-arr-btn\" class=\" btn btn-primary col-xs-3 col-xs-offset-1\"&gt; 设置localstrogeArray按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-8 \"&gt; &lt;h2&gt;Sessionstroge设置&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"col-xs-12\"&gt; &lt;button id=\"set-sessionstroge-arr-btn\" class=\" btn btn-infro col-xs-3 col-xs-offset-1\"&gt; 设置sessionstrogeArray按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt; &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; if (window.localStorage) &#123; console.log('localStorage') &#125; else &#123; console.log('not support localStorage') &#125; if (window.sessionStorage) &#123; console.log('sessionStorage') &#125; else &#123; console.log('not support sessionStorage') &#125; $('#set-cookie-btn').on('click', function() &#123; var name = $('#set-cookie-name').val(); var value = $('#set-cookie-value').val(); if (name !== null &amp;&amp; value !== null) &#123; addCookie(name, value, 3, '/setcookie'); &#125; &#125;) $('#get-cookie-btn').on('click', function() &#123; var name = $('#set-cookie-name').val(); var value = getCookie(name); $('#get-cookie-input').val(value); &#125;) $('#del-cookie-btn').on('click', function() &#123; var name = $('#set-cookie-name').val(); deleteCookie(name); &#125;) $('#set-localstroge-btn').on('click', function() &#123; var key = $('#set-localstroge-name').val(); var value = $('#set-localstroge-value').val(); if (name !== null &amp;&amp; value !== null) &#123; localStorage.setItem(key, value); &#125; &#125;) $('#get-localstroge-btn').on('click', function() &#123; var key = $('#set-localstroge-name').val(); var value = localStorage.getItem(key); $('#get-localstroge-input').val(value); &#125;) $('#del-localstroge-btn').on('click', function() &#123; var key = $('#set-localstroge-name').val(); localStorage.removeItem(key); &#125;) $('#del-localstroge-all-btn').on('click', function() &#123; localStorage.clear(); &#125;) $('#set-localstroge-arr-btn').on('click', function() &#123; setLocalstrogeArray(); &#125;) function setLocalstrogeArray() &#123; var arr = &#123; \"name\": \"moomoo\", \"age\": 2, \"eat\": \"apple\" &#125;; localStorage.setItem(\"arr\", JSON.stringify(arr)); arr = JSON.parse(localStorage.getItem(\"arr\")); console.log(arr) &#125; $('#set-sessionstroge-arr-btn').on('click', function() &#123; sessionStorage(); &#125;) function sessionStorage() &#123; var arr = &#123; \"name\": \"pp\", \"age\": 33, \"eat\": \"pear\" &#125;; var sessionStorage = window.sessionStorage; sessionStorage.setItem(\"yy\", JSON.stringify(arr)); &#125; &#125;); /*添加cookie*/ function addCookie(name, value, days, path) &#123; var name = escape(name); var value = escape(value); var expires = new Date(); expires.setTime(expires.getTime() + days * 3600000 * 24); //path=/，表示cookie能在整个网站下使用，path=/temp，表示cookie只能在temp目录下使用 path = path == \"\" ? \"\" : \";path=\" + path; //GMT(Greenwich Mean Time)是格林尼治平时，现在的标准时间，协调世界时是UTC //参数days只能是数字型 var _expires = (typeof days) == \"string\" ? \"\" : \";expires=\" + expires.toUTCString(); document.cookie = name + \"=\" + value + _expires + path; &#125; /*获取cookie*/ function getCookie(name) &#123; var arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\"); if (arr = document.cookie.match(reg)) return unescape(arr[2]); else return null; &#125; /*删除cookie*/ function deleteCookie(name, path) &#123; /**根据cookie的键，删除cookie，其实就是设置其失效**/ var name = escape(name); var expires = new Date(0); path = path == \"\" ? \"\" : \";path=\" + path; document.cookie = name + \"=\" + \";expires=\" + expires.toUTCString() + path; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"cookie","slug":"cookie","permalink":"https://liuchao0704.github.io/tags/cookie/"}]},{"title":"gulp 自动化构建工具小总结","date":"2017-02-12T12:32:50.000Z","path":"2017/02/12/gulpAuto/","text":"使用gulp一段时间了，编译less省时省力，记录一下自己的安装过程，也算是比较详细的gulp使用教程了。 本教程使用的工具以及安装环境 node.js git windows 完成效果 自动编译less文件生成css文件 当css,js 文件发生更改的时候浏览器自动为我们刷新 清除缓存,自动为css,js添加版本号例如 href=&quot;css/app.css?v=98ad83c3b4&quot; 1.安装node.js、git2.全局安装gulp 1$ npm install gulp -g 3.本地安装 gulp老规矩E盘下新建文件夹(比如www，注意不要有中文名称)并执行 1$ npm init npm init命令会为你创建一个package.json文件，这个文件保存着这个项目相关信息。比如你用到的各种依赖（这里主要是插件）（终端会自动出现下面内容，这里先随便填就行）创建完之后，我们执行下本地安装的命令：1$ npm install gulp --save-dev 执行完之后，node将创建node_modules文件夹，里面有个gulp文件夹。 4. 项目目录结构 在E盘/www文件夹下面我们使用app文件夹作为开发目录（所有的源文件都放在这下面），dist文件夹用来存放生产环境下的内容。这些文件名，你想怎么起都行，但请务必记住你的目录结构。现在来创建gulpfile.js。 5. 第一个gulp 任务你需要先在文件根目录下创建一个gulpfile.js文件，查看一下之前的文件结构。 在文件里面输入这样的代码 var gulp = require(&#39;gulp&#39;);这行命令告知Node去node_modules中查找gulp包，先局部查找，找不到就去全局环境中查找。找到之后就会赋值给gulp变量，然后我们就可以使用它了。 简单的任务如下所示：123gulp.task('task-name', function() &#123; // Stuff here &#125;); task-name 是给你的任务起的名字，稍后在命令行中执行gulp task-name，将运行该任务。写个HelloWorld，是这样的：1234var gulp = require('gulp'); gulp.task('hello', function() &#123; console.log('Hello World!'); &#125;); 命令行中执行：$ gulp hello 输出’Hello World!’ 表示成功了。 gulp任务通常会包含两个特定的Gulp方法和一系列Gulp插件。12345gulp.task('task-name', function () &#123; return gulp.src('source-files') // Get source files with gulp.src .pipe(aGulpPlugin()) // Sends it through a gulp plugin .pipe(gulp.dest('destination')) // Outputs the file in the destination folder&#125;) 6.简单的less 任务由于本人用的是less 所以这里讲一下less插件 。其实less 和 sass插件安装几乎是同理可得，引入插件的同时首先要安装一下插件 1$ npm install gulp-less --save-dev 记得在app 文件夹下有less文件夹 并且在less文件夹下面新建style.less文件。找到index.hmtl 并引入样式 打开之前的gulpfile.js 添加一下less任务 123456var less = require('gulp-less'); gulp.task('less', function () &#123; gulp.src(['app/less/style.less']) .pipe(less()) .pipe(gulp.dest('app/css')); //将会在app/css下生成style.css &#125;); 7. Node 通配符通配符是一种匹配模式，允许你匹配到多个文件。不止是Node，很多平台都有，有点像正则表达式。使用通配符，计算机检查文件名和路径进行匹配。大部分时候，我们只需要用到下面4种匹配模式： *.scss： * 号匹配当前目录任意文件，所以这里 *.scss 匹配当前目录下所有scss文件 **/*.scss：匹配当前目录及其子目录下的所有scss文件。 !not-me.scss:!号移除匹配的文件，这里将移除not-me.scss *.+(scss|sass) ：+号后面会跟着圆括号，里面的元素用|分割，匹配多个选项。这里将匹配scss和sass文件。 改造一下less 任务 12345gulp.task('less', function() &#123; return gulp.src('app/less/**/*.less') .pipe(less()) .pipe(gulp.dest('app/css')) &#125;) 8.自动编译 监听任务现在我们能处理多个文件了，但是不想每次都要执行命令，怎么办？Gulp就是为懒人而生的，我们可以使用watch命令，自动检测并执行。 Gulp提供watch方法给我们，语法如下： 12//Gulp watch syntax gulp.watch('files-to-watch', ['tasks', 'to', 'run']); 所以同时监听多个less 任务就是 123gulp.task('watch', function()&#123; gulp.watch('app/less/**/*.less', ['less']); &#125;) 当编译less时出现语法错误或者其他异常，会终止watch事件，通常需要查看命令提示符窗口才能知道，这并不是我们所希望的，所以我们需要处理出现异常并不终止watch事件（gulp-plumber），并提示我们出现了错误（gulp-notify）。 安装两个新插件 12$ npm install gulp-plumber --save-dev$ npm install gulp-notify --save-dev 继续修改一下less任务12345678var notify = require('gulp-notify'); var plumber = require('gulp-plumber'); gulp.task('less', function()&#123; return gulp.src('app/less/**/*.less') .pipe(plumber(&#123;errorHandler: notify.onError('Error: ')&#125;)) .pipe(less()) .pipe(gulp.dest('app/css')) &#125;); 9.使用Browser Sync自动刷新浏览器记得引入新插件首先要安装1$ npm install browser-sync --save-dev 在gulpfile.js中 新建任务1var browserSync = require('browser-sync'); 我们创建一个broswerSync任务，我们需要告知它，根目录在哪里。 1234567gulp.task('browserSync', function() &#123; browserSync(&#123; server: &#123; baseDir: 'app' &#125;, &#125;) &#125;) 我们稍微修改一下之前的代码，让每次css文件更改都刷新一下浏览器： 123456789gulp.task('less', function()&#123; return gulp.src('app/less/**/*.less') .pipe(plumber(&#123;errorHandler: notify.onError('Error: ')&#125;)) .pipe(less()) .pipe(gulp.dest('app/css')) .pipe(browserSync.reload(&#123; stream: true &#125;)) &#125;); 现在我们配置好BroswerSync了，我们需要运行这两个命令。我们可以在watch任务之前告知gulp，先把browserSync和less任务执行了再说。 语法如下： 123gulp.task('watch', ['array', 'of', 'tasks', 'to', 'complete','before', 'watch'], function ()&#123; // ... &#125;) 不止是less修改的时候需要刷新浏览器吧？js,html 改变都要刷新浏览器 ： 12345gulp.task('watch',['browserSync', 'less'], function()&#123; gulp.watch('app/less/**/*.less', ['less']); gulp.watch('app/*.html', browserSync.reload); gulp.watch('app/js/**/*.js', browserSync.reload); &#125;) 好了至此我们已经完成了所有的操作。$ gulp watch一下就能实现自动编译less 并且根据css ,html 等文件的改变自动刷新浏览器了。 以上参考资料： http://www.tuicool.com/articles/QzaqAbF http://www.ydcss.com/archives/18 http://www.ydcss.com/archives/34 10. BrowserSync 代理模式查看一下之前的gulpfile.js1234567gulp.task('browserSync', function() &#123; browserSync(&#123; server: &#123; baseDir: 'app' &#125;, &#125;) &#125;) 这个命令用于纯静态站点，也就是仅一些.html文件的情况。如果是动态站点，则使用代理模式。例如PHP站点，已经建立了一个本地服务器如http://localhost:8080，此时会是这样的命令，我们来做个修改 12345gulp.task('browserSync', function() &#123; browserSync(&#123; proxy: \"http://localhost:8080/xxx/app/\" //这个xxx文件夹稍后根据实际情况而定 &#125;) &#125;) 这样手机也可以访问电脑里面的网站了 $ gulp watch一下 电脑、手机端可以自动刷新了。最后分享一下 gulpfile.js 代码 12345678910111213141516171819202122232425262728var gulp = require('gulp'), less = require('gulp-less'), notify = require('gulp-notify'), plumber = require('gulp-plumber'), browserSync = require('browser-sync'); gulp.task('hello', function() &#123; console.log('Hello World!'); &#125;); gulp.task('less', function()&#123; return gulp.src('app/less/**/*.less') .pipe(plumber(&#123;errorHandler: notify.onError('Error: ')&#125;)) .pipe(less()) .pipe(gulp.dest('app/css')) .pipe(browserSync.reload(&#123; stream: true &#125;)) &#125;); gulp.task('watch',['browserSync', 'less'], function()&#123; gulp.watch('app/less/**/*.less', ['less']); gulp.watch('app/*.html', browserSync.reload); gulp.watch('app/js/**/*.js', browserSync.reload); &#125;) // Browser-sync task, only cares about compiled CSS gulp.task('browserSync', function() &#123; browserSync(&#123; proxy: \"http://127.0.0.1/xxx/app/\" //xxx 根据实际情况而定 &#125;) &#125;) 11.自动为css，js 增加版本号gulp 在原html文件上自动化添加js、css版本号原理 修改js和css文件 通过对js,css文件内容进行hash运算，生成一个文件的唯一hash字符串(如果文件修改则hash号会发生变化) 替换html中的js,css文件名，生成一个带版本号的文件名 原html文件代码 12&lt;link rel=\"stylesheet\" href=\"../css/default.css\"&gt;&lt;script src=\"../js/app.js\"&gt;&lt;/script&gt; 预期效果：在原目录结构下html文件代码 12&lt;link rel=\"stylesheet\" href=\"../css/default.css?v=5a636d79c4\"&gt;&lt;script src=\"../js/app.js?v=3a0d844594\"&gt;&lt;/script&gt; 安装插件 123npm install --save-dev gulp-revnpm install --save-dev gulp-rev-collectornpm install --save-dev run-sequence 继续修改gulpfile.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//引入gulp和gulp插件var gulp = require('gulp'), runSequence = require('run-sequence'), rev = require('gulp-rev'), revCollector = require('gulp-rev-collector');//定义css、js源文件路径var cssSrc = 'css/*.css', jsSrc = 'js/*.js';//CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revCss', function()&#123; return gulp.src(cssSrc) .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('rev/css'));&#125;);//js生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revJs', function()&#123; return gulp.src(jsSrc) .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('rev/js'));&#125;);//Html替换css、js文件版本gulp.task('revHtml', function () &#123; return gulp.src(['rev/**/*.json', 'View/*.html'])//views是本地html文件的路径，可自行配置*/ .pipe(revCollector()) .pipe(gulp.dest('View'));///*Html更换css、js文件版本,WEB-INF/views也是和本地html文件的路径一致*/&#125;);//开发构建gulp.task('dev', function (done) &#123; condition = false; runSequence( ['revCss'], ['revJs'], ['revHtml'], done);&#125;);gulp.task('default', ['dev']); 执行gulp命令后的效果 123456//rev目录下生成了manifest.json对应文件&#123; \"default.css\": \"default-803a7fe4ae.css\"&#125;&lt;link rel=\"stylesheet\" href=\"../css/default-803a7fe4ae.css\"&gt;&lt;script src=\"../js/app-3a0d844594.js\"&gt;&lt;/script&gt; 很显然这不是我们需要的效果,所以我们要继续修改 123打开node_modules\\gulp-rev\\index.js第144行 manifest[originalFile] = revisionedFile;更新为: manifest[originalFile] = originalFile + '?v=' + file.revHash; 123打开nodemodules\\rev-path\\index.js第10行 return filename + '-' + hash + ext;更新为: return filename + ext; 123打开node_modules\\gulp-rev-collector\\index.js第31行if ( !_.isString(json[key]) || path.basename(json[key]).replace(new RegExp( opts.revSuffix ), ' ') !== path.basename(key) ) &#123;更新为: if ( !_.isString(json[key]) || path.basename(json[key]).split('?')[0] !== path.basename(key) ) &#123; 再执行gulp命令，得到的结果如下(效果正确): 12&lt;link rel=\"stylesheet\" href=\"../css/default.css?v=33379df310?v=803a7fe4ae\"&gt;&lt;script src=\"../js/app.js?v=3a0d844594?v=3a0d844594\"&gt;&lt;/script&gt; 有没有发现，会在版本号后面再添加一个版本号，因为gulp只替换了原来文件名，这样又不符合预期效果了，所以我们想到，还需要修改插件的替换正则表达式。 123打开node_modules\\gulp-rev-collector\\index.js第117行 regexp: new RegExp( '([\\/\\\\\\\\\\'\"])' + pattern, 'g' ),更新为: regexp: new RegExp( '([\\/\\\\\\\\\\'\"])' + pattern+'(\\\\?v=\\\\w&#123;10&#125;)?', 'g' ), 现在你不管执行多少遍gulp命令，得到的html效果都是 12&lt;link rel=\"stylesheet\" href=\"../css/default.css?v=5a636d79c4\"&gt;&lt;script src=\"../js/app.js?v=3a0d844594\"&gt;&lt;/script&gt; 以上参考资料：https://my.oschina.net/enjoymore/blog/830622 最后分享一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var gulp = require('gulp'), less = require('gulp-less'), notify = require('gulp-notify'), plumber = require('gulp-plumber'), browserSync = require('browser-sync'), runSequence = require('run-sequence'), rev = require('gulp-rev'), revCollector = require('gulp-rev-collector');// 定义css js 路径var cssUrl = 'src/css/*.css', jsUrl = 'src/js/*.js';// hello 任务gulp.task('hello', function() &#123; console.log('Hello World!');&#125;);//less 任务gulp.task('less', function() &#123; return gulp.src('src/css/less/app.less') .pipe(plumber(&#123; errorHandler: notify.onError('Error: &lt;%= error.message %&gt;') &#125;)) .pipe(less()) .pipe(gulp.dest('src/css')) .pipe(browserSync.reload(&#123; stream: true &#125;))&#125;);// 监听任务gulp.task('watch', ['browserSync', 'less'], function() &#123; gulp.watch('src/css/less/*.less',['less']); gulp.watch('src/css/app.css',['dev']); gulp.watch('src/js/*.js',['dev']); gulp.watch('src/*.html',browserSync.reload);&#125;)// Browser-sync task, only cares about compiled CSSgulp.task('browserSync', function() &#123; browserSync(&#123; proxy: \"http://127.0.0.1/XXX/src/#/\" //根据实际情况写 &#125;)&#125;)//CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revCss', function() &#123; return gulp.src(cssUrl) .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('rev/css'));&#125;);//js生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revJs', function() &#123; return gulp.src(jsUrl) .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('rev/js'));&#125;);//Html更换css、js文件版本gulp.task('revHtml', function() &#123; return gulp.src(['rev/**/*.json', 'src/*.html']) /*WEB-INF/views是本地html文件的路径，可自行配置*/ .pipe(revCollector()) .pipe(gulp.dest('src/')); /*Html更换css、js文件版本,WEB-INF/views也是和本地html文件的路径一致*/&#125;);//开发构建gulp.task('dev', function(done) &#123; condition = false; runSequence( ['revCss'], ['revJs'], ['revHtml'], done);&#125;);//gulp.task('default', ['dev']);","tags":[{"name":"gulp","slug":"gulp","permalink":"https://liuchao0704.github.io/tags/gulp/"}]},{"title":"JS Date对象学习","date":"2017-02-08T13:40:44.000Z","path":"2017/02/08/date/","text":"关于 Date 对象处理方法 利用Date()构造函数可以创建指定时间日期对象，例如:12345678910var theDate = new Date();console.log(theDate);console.log('今年：' + theDate.getFullYear() + '\\n') // 获取年份console.log('今月：' + (parseInt(theDate.getMonth())+1) + '\\n') // 获取月 console.log('今日：' + theDate.getDate() + '\\n') // 获取日console.log('星期：' + theDate.getDay() + '\\n') // 获取星期console.log('小时：' + theDate.getHours() + '\\n') // 获取小时console.log('分钟：' + theDate.getMinutes() + '\\n') // 获取分钟：console.log('秒:' + theDate.getSeconds()+ '\\n') // 获取秒console.log('毫秒:' + theDate.getMilliseconds() + '\\n') // 获取毫秒 上面是对于Date()构造函数最简单的应用了，Date对象具有多种构造函数123456789new Date()new Date(milliseconds)new Date(datestring)new Date(year, month)new Date(year, month, day)new Date(year, month, day, hours)new Date(year, month, day, hours, minutes)new Date(year, month, day, hours, minutes, seconds)new Date(year, month, day, hours, minutes, seconds, microseconds) new Date()当 new Date()构造函数而不传递参数的时候，新创建的对象自动获得当前时间。以下代方便获取Date对象时间戳 12345678910var start = +new Date(); // do somethingvar stop = +new Date(), result = stop - start;// 对于支持 Date.now()的浏览器var start = Date.now(); //do somethingvar stop = Date.now(), result = stop- start; Date.parse()如果想要获取指定日期或者时间的日期对象，可以通过Date.parse()或者Date.UTC()。Date.parse()接收一个表示日期的字符串参数，然后根据这个字符串参数返回相应日期的毫秒数。 123var someDate = new Date(Date.parse('May 25,2004'));//等同于var someDate = new Date('May 25,2004') Date.UTC()Date.UTC() 方法同样也会返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC() 的参数分别是年份，基于0的月份(1月是0，2月是1)、月中的哪一天、小时数、分钟、秒、以及毫秒数。在这些参数中，只有前两个参数是必须的。其他可以忽略。其中月中的天数默认为1号，其他为0。 1var y = new Date(Date.UTC(2000,0)) 简单总结下 new Date()，没有参数的时候，创建的是 当前 时间日期对象。 new Date(milliseconds)，当参数为数字的时候，那么这个参数就是时间戳，被视为毫秒，创建一个距离1970年1月一日指定毫秒的时间日期对象。 new Date(datestring)，此参数是一个字符串，并且此字符串一定能够使用Date.parse()转换。 以下六个构造函数是精确定义: year，是一个整数，如果是0-99，那么在此基础上加1900，其他的都原样返回。 month,是一个整数，范围是0-11。 day，是一个整数，范围是1-31。 hours，是一个整数，范围是0-23。 minutes，是一个整数，范围是0-59。 seconds，是一个整数，范围是0-59. microseconds，是一个整数，范围是0-9999。 一些常用扩展 将日期变成指定格式123456789101112131415161718192021 Date.prototype.format = function (fmt) &#123; var o = &#123; \"M+\": this.getMonth() + 1, //月份 \"d+\": this.getDate(), //日 \"h+\": this.getHours(), //小时 \"m+\": this.getMinutes(), //分 \"s+\": this.getSeconds(), //秒 \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \"S\": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); &#125; for (var k in o) &#123; if (new RegExp(\"(\" + k + \")\").test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); &#125; &#125; return fmt; &#125;var NewDate = new Date().format('yyyy-MM-dd')将输出指定格式的今日日期 将指定格式的日期变成时间戳123456789function convertTimes( date )&#123; var date = date.split('-'); d = new Date(); d.setFullYear(date[0]); d.setMonth(date[1]-1); d.setDate(date[2]); return d.getTime();&#125; console.log( convertTimes('2017-2-3'));","tags":[{"name":"js","slug":"js","permalink":"https://liuchao0704.github.io/tags/js/"},{"name":"date","slug":"date","permalink":"https://liuchao0704.github.io/tags/date/"}]},{"title":"hexo+github 部署个人网站","date":"2017-01-31T11:54:21.000Z","path":"2017/01/31/hexo-github/","text":"如果你对个人博客感兴趣想拥有一个属于自己的网站，对markdown语法有了解，有自己的github账号，平时习惯用markdown记笔记。那么用hexo来打造自己的个人网站就很容易上手了。 主要流程 安装并配置hexo github新建仓库并上传 注册七牛云用图床软件保存图片(如果需要的话) 安装并配置hexo安装hexo1$ npm install -g hexo 初始化 在电脑E盘下直接新建一个blog目录（windows系统下文件夹命名避免出现中文）12$ cd /e/blog/$ hexo init 查看一下E/blog 生成的目录 生成并启动hexo12$ hexo g # 生成$ hexo s # 启动服务 $ hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考百度。如果顺利打开的话页面是这样子的 不喜欢这个主题？ 没有关系随时都可以修改12$ cd /e/blog/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在themes文件夹下面。点击进去就可以看到yilia文件夹。 找到blog目录下的_config.yml文件打开并修改theme: yilia 执行一下123$ hexo clean$ hexo g$ hexo s 记住如果修改了根目录下的_config.yml 都要重新$ hexo s 才能看到效果 修改主题里面的参数 找到themes/yilia文件下的_config.yml 照着备注的中文名称开始修改吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# Headerauthor: 你独一无二的昵称menu: 主页: / 所有文章: /archives# SubNavsubnav: github: \"https://github.com/你自己的github账号\" rss: \"#\" zhihu: \"#\" #qq: \"#\" #weixin: \"#\" #jianshu: \"#\" #douban: \"#\" #mail: \"mailto:litten225@qq.com\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: # Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 请在需要打赏的文章的md文件头部，设置属性reward: true# 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 0# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # Miscellaneousbaidu_analytics: ''google_analytics: ''favicon: /favicon.png#你的头像urlavatar: 'http://okn6xxp76.bkt.clouddn.com//*******.png'#是否开启分享share_jia: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: '#0c0d25' # 右滑板块背景 slider: 'linear-gradient(200deg,#a0cfe4,#e8c37e)' # # slider的设置slider: # 是否默认展开tags板块 showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' friends: '友链' aboutme: '关于我'friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 很高兴&lt;br&gt;你能来到这里&lt;br&gt;谢谢大家 关于头像设置（尺寸118*118 大小10-20Kb即可）我的头像是用七牛云存放。参考链接：http://www.jianshu.com/p/6dce6094b http://mpic.lzhaofu.cn 操作比较简单，如果不想设置头像的可以略过。 动手写一篇博客试试吧12$ cd /e/blog/ # 切换到blog文件$ hexo new 'hello' 回到blog/source/_posts/找到 hello.md 打开支持md语法的编辑器就可以愉快的编写了 12345678title: 鸡年大吉date: 2017-01-30 20:18:00tags: 随笔---预览内容&lt;!-- more --&gt;正文部分开始 github新建仓库并设置登录github 并新建一个仓库 请注意用户名和仓库名一一对应必须一模一样 配置SSH1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。1ssh-keygen -t rsa -C \"邮件地址\" 代码参数含义：-t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。 以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如12Generating public/private rsa key pair.# Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 当然，你也可以不输入文件名，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码），当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了，如：12Enter passhrase(empty fo no passphrase):# Enter same passphrase again: 最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.# Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 当你看到上面这段代码,那就说明你的 SSH key 已经创建成功，你只需要添加到github的SSH key上就可以了。 添加你的 SSH key 到 github上面去首先你需要拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容，如：1$ clip &lt; ~/.ssh/id_rsa.pub 登录你的github账号，点击头像（ Settings ）进入 &gt; SSH and GPG keys -&gt; New SSH key 把你本地生成的密钥复制到里面（key文本框中）title随便填。保存就ok了。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示1Are you sure you want to continue connecting (yes/no)? 输入yes，然后会看到：1Hi XXXX! Youve successfullu authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！此时你还需要配置： 12$ git config --global user.name \"你的名字\"// 你的github用户名，非昵称$ git config --global user.email \"xxx@xx.com\"// 填写你的github注册邮箱 可能出现的问题在window 系统下操作git 总会出现一些问题。如果你遇到这个提示1Could not open a connection to your authentication agent. 尝试解决的方案12islue@localhost $ ssh-agent bash --login -iislue@localhost $ ssh-add 参考资料：http://www.cnblogs.com/cheche/archive/2011/01/07/1918825.html 本地上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。首先，ssh key肯定要配置好。其次，配置_config.yml中有关deploy的部分：正确写法：1234deploy: type: git repository: git@github.com:你的名字/你的名字.github.io.git branch: master 安装一下插件1$ npm install hexo-deployer-git --save 最后一步也就是重复之前的操作123$ hexo clean$ hexo g$ hexo d 成功之后打开 https://liuchao0704.github.io/ 即可预览 总结这也是自己第一次摸索了大半天做出来的效果，遇到了一些坑。不过上网发现很多人有用hexo搭建自己的博客，资料很丰富。遇到问题也能及时百度解决之。最后时间关系有些功能没有添加：比如评论留言，比如主题里面 一些个性化配置。有机会一定会抽空改进。 我参考的资料：http://hetaoo.iteye.com/blog/2323944http://blog.csdn.net/jzooo/article/details/46781805http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html","tags":[{"name":"hexo","slug":"hexo","permalink":"https://liuchao0704.github.io/tags/hexo/"}]}]