[{"title":"二进制浮点数","date":"2020-02-10T07:32:20.000Z","path":"2020/02/10/float/","text":"简单总结二进制浮点数原理 根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式： $$V = (-1)^{s}\\times M \\times2^{E}$$ (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。 M表示有效数字，大于等于1，小于2。 2^E表示指数位数。 IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。 位数 0 1-8 9-31 32 S （符号位） E （实际加上127） M（参考下面规则） 位数 0 1-11 12-63 64 S（符号位） E （实际加上1023） M （参考下面规则） IEEE 754对有效数字M和指数E，还有一些特别规定。前面说过，1≤M&lt;2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。然后，指数E还可以再分成三种情况： E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。 E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。 E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。 浮点数 263.3 表示 正数S = 0； 263(10) = 100000111(2); 0.3(10) = 010011001100110011001100…(2); 100000111.010011001100110011001100 = 1.00000111010011001100110011001100 * 2 ^ 8; E = 8 + 127 = 135(10)= 10000111(2); M = 1.00000111010011001100110011001100; E 不全为0或者1，M = 00000111010011001100110011001100 0100 -0011-1000-0011-1010-0110-0110-0110 与官网比较","tags":[{"name":"二进制浮点数","slug":"二进制浮点数","permalink":"https://liuchao0704.github.io/tags/二进制浮点数/"},{"name":"number","slug":"number","permalink":"https://liuchao0704.github.io/tags/number/"}]},{"title":"原生函数","date":"2020-01-30T03:30:20.000Z","path":"2020/01/30/nativeFunc/","text":"原生函数总结归纳 常用原生函数 Sting() Number() Boolean() Array() Object() Function() RegExp() Date() Error() Symbol() —— ES6中新加入的 原生函数可以被当作构造函数来使用，但是其构造出来的是封装了基本类型值的封装对象 内部属性[[Class]]所有typeof返回值为“object”的对象（如数组）都包含一个内部属性[[Class]]。这个属性无法直接访问，一般通过Object.prototype.toString(…)来查看 1234Object.prototype.toString.call([1,2])\"[object Array]\"Object.prototype.toString.call(/d/g)\"[object RegExp]\" 封装对象的包装基本类型没有.length 和 .toString()这样的属性和方法。需要通过封装对象才能访问，JavaScirpt会自动为基本类型的值包装一个封装对象。 拆封如果想要得到封装对象中的基本类型值，可以使用valueOf()函数","tags":[{"name":"原生函数","slug":"原生函数","permalink":"https://liuchao0704.github.io/tags/原生函数/"},{"name":"js","slug":"js","permalink":"https://liuchao0704.github.io/tags/js/"}]},{"title":"强制类型转换","date":"2020-01-12T07:17:20.000Z","path":"2020/01/12/casts/","text":"梳理强制类型的转换 值类型转换 将值从一种类型转换为另一种类型通常称为类型转换 显示（强制类型）转换 —— 发生在静态语言编译 隐式（强制类型）转换 —— 发生在动态语言运行 抽象值操作 ToString ToNumber ToBoolean ToString 对于普通对象来说，除非自行定义，否则toString（）（Object.prototype.toString（））返回内部属性[[Class]]的值 数组的默认toString（）方法经过了重新定义，将所有单元字符串化以后再用’,’连接起来 JSON字符串化（并非强制类型转换只是规则与ToString类似）工具函数 JSON.stringify（...）在将JSON对象序列化为字符串时也用到了ToString 字符串、数字、布尔值和null的 JSON.stringify（...）规则和toString（）基本相同，只不过序列化的结果总是字符串 JSON.stringify（...）在对象中遇到undefined ，function 和 symbol时会自动将其忽略，在数组中则会返回null （以保证单元位置不变） undefined、任意的函数以及 symbol 被 JSON.stringify（） 作为单独的值进行序列化时，都会返回 undefined 如果传递给JSON,stringify（...）的对象中定义了toJSON（）方法，那么该方法会在字符串化前调用，以便将对象转化为安全的JSON值 ToNumber 对象（包括数组）会首先转化为相应的基本类型值 处理失败返回NaN 检查该值是否有valueOf（）方法 如果有 使用该值进行强制类型转换 如果没有 使用toString（）返回值（如果存在）来进行强制类型转换 原始值 Number false 0 true 1 undefined NaN null 0 ToBooleanJavaScript 假值（falsy value） undefined null false -0,+0和NaN “ “（空字符串） 真值 除假值以外的值，所有的对象都是真值 假值对象 浏览器在JavaScript语法创建了一些外来值，这些就是”假值对象”，将他们强制类型转换为布尔值时为false documen.all 显示强制类型转化字符串和数字之间的显示转换 一元运算符 获取时间戳 var timestamp = +new Date（） es6获取当前时间戳 var timestamp = Date.now（） 获取指定时间的时间戳 var timestamp = new Date（）.getTime（） ~ 运算符（字位操作符 “非”） ~x 大致等于 -（x+1） indexOf（…） === -1 , 利用 ~ 可以转化为 0 ~~ 字位截除 显示解析数字字符串 解析非字符串 parseInt（0.00008） = parseInt(“0.00008”） = 0 parseInt（0.000008） = parseInt（”8e-7”） = 8 parseInt（”0x10”） = 16 （16进制） parseInt（”103”,2） = 2 （3为无效数字） 显示转化为布尔值 !! 强制转化 一元运算符！显示的将值强制类型转换为布尔值。但是它同时还将值进行反转。所以!! 可以强制转换为布尔值，并且将结果反转回原值 if 判断 三目运算 隐式强制类型转换字符串和数字之间的隐式强制类型转换 “+” 作为字符串拼接 “-“ 作为数字减法运算符 （”3.14” - 0 会将”3.14”强制转换为3.14） 布尔值到数字的隐式强制类型转换 复杂的布尔逻辑转换为数字加法 隐式强制类型转换为布尔值 if （…）语句中的条件判断表达式 for （…;…;…）语句中条件判断表达式 while（）和 do while（）循环中的条件表达式 ？：中的条件判断表达式 逻辑运算符||（逻辑或）和 &amp;&amp; （逻辑与）左边的操作数（作为条件判断表达式） 宽松相等和严格相等 “==允许在相等比较中进行强制类型转换，而===不允许” NaN 不等于 NaN +0 等于 -0","tags":[{"name":"类型转换","slug":"类型转换","permalink":"https://liuchao0704.github.io/tags/类型转换/"}]},{"title":"String字符串 & 数字","date":"2019-12-21T07:32:20.000Z","path":"2019/12/21/string&number/","text":"字符串，数字，null，undefined，特殊数字，特殊等式 String.concat()concat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 语法 1str.concat(string2, string3[, ..., stringN]) 示例 12var hello = \"Hello, \";console.log(hello.concat(\"Kevin\", \" have a nice day.\")); /* Hello, Kevin have a nice day. */ 性能强烈建议使用 赋值操作符（+, +=）代替 concat 方法。 String.slice() / String.substring() 方法 参数1 indexStart 参数2 indexEnd 返回值 slice 1. 如果小于0 则 加上字符串的长度 2. 如果start 大于等于 end 返回空字符串 1. 如果小于0 则 加上字符串的长度 2. 如果省略该参数，slice() 会一直提取到字符串末尾 包含给定字符串的指定部分的新字符串 substring 1. 参数小于0 或者为NaN 则被当作0 2. 如果start大于end 则互换 3如果start等于end 返回空字符串 1. 参数小于0 或者为NaN 则被当作0 2. 如果省略该参数，substring()会一直提取到字符串末尾 包含给定字符串的指定部分的新字符串 JavaScript中的数字类型是基于IEEE 754标准来实现的，该标准通常也被称为“浮点数”。JavaScipt使用的是“双精度”格式（64位 二进制）。 JavaScript中的”整数“就是没有小数的十进制。所以42.0即等同于”整数“42。 较小的数值如何判断0.1 + 0.2 = 0.3 ？ 最常见的是设置一个误差范围值，通常称为”机器精度“（machine epsilon），对于JavaScript的数字来说，这个值通常是2^-52。 12345678910if (!Number.EPSILON) &#123; Number.EPSILON = Math.pow(2, -52);&#125;function numbersCloseEnoughToEqual(n1, n2) &#123; return Math.abs(n1 - n2) &lt; Number.EPSILON;&#125;var result = 0.1 + 0.2;var result1 = 0.3;numbersCloseEnoughToEqual(result, result1) // true 整数的检测 ES6中的Number.isInteger()； typeof为number,并且除以1余数为0； 123456789101112// polyfill if (!Number.isInteger) &#123; Number.isInteger = function(num) &#123; return typeof num === 'number' &amp;&amp; num % 1 === 0; &#125;&#125;Number.isInteger = Number.isInteger || function(value) &#123; return typeof value === 'number' &amp;&amp; isFinite(value) &amp;&amp; Math.floor(value) === value;&#125;; 特殊数值 undefined 从未赋过值 ，没有值 null 空值， 曾赋过值，目前没有值 特殊的数字 NaN 无穷数 0 和 -0 NaN NaN是一个“不是数字的数字” ，typeof 是 number类型 NaN是一个特殊值，它和自身不相等，是唯一一个非自反的值； Number.isNaN 可以检测是否是NaN； 1234567891011121314// polyfillif (!Number.isNaN) &#123; Number.isNaN = function(n) &#123; return &#123; typeof n === 'number' &amp;&amp; window.isNaN(n) &#125; &#125;&#125;if (!Number.isNaN) &#123; Number.isNaN = function(n) &#123; return n !== n; &#125;&#125; 特殊等式 NaN !== NaN -0 === 0","tags":[{"name":"js","slug":"js","permalink":"https://liuchao0704.github.io/tags/js/"},{"name":"number","slug":"number","permalink":"https://liuchao0704.github.io/tags/number/"},{"name":"string","slug":"string","permalink":"https://liuchao0704.github.io/tags/string/"}]},{"title":"Array数组","date":"2019-12-17T01:32:20.000Z","path":"2019/12/17/array/","text":"数组方法总结&amp;es6新增API Array.of()Array.of() 方法创建一个具有可变数量参数的新数组示例，而不考虑参数的数量或类型。 语法 1Array.of(element0[, element1[, ...[, elementN]]]) 参数elementN任意个参数，将按顺序成为返回数组中的元素。 返回值新的 Array 示例。 示例 1234var arr = [1, 2, 3]; //字面量创造函数var arr1 = Array(3); //产生空槽数组 [empty × 3]console.log(Array.of(3)) // [3]console.log(Array.of()) // [] Array.from()Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组示例。 语法 1Array.from(arrayLike[, mapFn[, thisArg]]) 参数 arrayLike 想要转换成数组的伪数组对象或可迭代对象 mapFn (可选参数) 如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg(可选参数)执行回调函数mapFn 时 this 对象 返回值一个新的数组示例 示例 123456789Array.from('foo'); // [ \"f\", \"o\", \"o\" ] function f() &#123; return Array.from(arguments); &#125; f(1, 2, 3); // [ 1, 2, 3 ] Array.from([1, 2, 3], x =&gt; x + x);// [2, 4, 6] Array.isArray()Array.isArray() 用于确定传递的值是否是一个 Array。 语法 1Array.isArray(obj) 参数 obj 需要检测的值 返回值 如果值是 Array，则为true; 否则为false。 示例 1234567// 下面的函数调用都返回 trueArray.isArray([]);Array.isArray([1]);Array.isArray(new Array());Array.isArray(new Array('a', 'b', 'c', 'd'))// 鲜为人知的事实：其实 Array.prototype 也是一个数组。Array.isArray(Array.prototype); Polyfill假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。 12345if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125; Array.copyWithin()copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。 语法 1arr.copyWithin(target[, start[, end]]) 参数 target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。 如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。 start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。 如果 start 被忽略，copyWithin 将会从0开始复制。 end 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。 如果 end 被忽略，copyWithin 方法将会一直复制至数组结尾（默认为 arr.length）。 返回值改变后的数组。 示例 12345678910111213141516let numbers = [1, 2, 3, 4, 5];numbers.copyWithin(-2);// [1, 2, 3, 1, 2]numbers.copyWithin(0, 3);// [4, 5, 3, 4, 5]numbers.copyWithin(0, 3, 4);// [4, 2, 3, 4, 5]numbers.copyWithin(-2, -3, -1);// [1, 2, 3, 3, 4][].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3);// &#123;0: 1, 3: 1, length: 5&#125; Array.fill()fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 语法 1arr.fill(value[, start[, end]]) 参数 value 用来填充数组元素的值。 start 可选， 起始索引，默认值为0。 end 可选，终止索引，默认值为 this.length。 返回值修改后的数组 示例 12345678910111213141516[1, 2, 3].fill(4); // [4, 4, 4][1, 2, 3].fill(4, 1); // [1, 4, 4][1, 2, 3].fill(4, 1, 2); // [1, 4, 3][1, 2, 3].fill(4, 1, 1); // [1, 2, 3][1, 2, 3].fill(4, 3, 3); // [1, 2, 3][1, 2, 3].fill(4, -3, -2); // [4, 2, 3][1, 2, 3].fill(4, NaN, NaN); // [1, 2, 3][1, 2, 3].fill(4, 3, 5); // [1, 2, 3]Array(3).fill(4); // [4, 4, 4][].fill.call(&#123; length: 3 &#125;, 4); // &#123;0: 4, 1: 4, 2: 4, length: 3&#125;// Objects by reference.var arr = Array(3).fill(&#123;&#125;) // [&#123;&#125;, &#123;&#125;, &#123;&#125;];// 需要注意如果fill的参数为引用类型，会导致都执行同一个引用类型// 如 arr[0] === arr[1] 为truearr[0].hi = \"hi\"; // [&#123; hi: \"hi\" &#125;, &#123; hi: \"hi\" &#125;, &#123; hi: \"hi\" &#125;] Array.reduce()reduce()方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。可以简单的理解为累加 语法 1arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 参数 callback 执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数：**accumulator** 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。 **currentValue** 数组中正在处理的元素。 **index** 可选，数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。 **array** 可选 调用reduce()的数组 initialValue 可选，作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 返回值函数累计处理的结果 描述回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。 注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。 示例 累加 二维数组转化一维数组 计算数组中每个元素出现的次数 数组去重 注意： 如果你正在使用一个可以兼容Set 和 Array.from()的环境， 你可以使用let orderedArray = Array.from(new Set(myArray));来获得一个相同元素被移除的数组。 123456789101112131415161718192021222324252627282930313233343536var sum = [0, 1, 2, 3].reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue;&#125;, 0);// 和为 6var flattened = [[0, 1], [2, 3], [4, 5]].reduce( function(a, b) &#123; return a.concat(b); &#125;, []);// flattened is [0, 1, 2, 3, 4, 5]var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];var countedNames = names.reduce(function (allNames, name) &#123; if (name in allNames) &#123; allNames[name]++; &#125; else &#123; allNames[name] = 1; &#125; return allNames;&#125;, &#123;&#125;);// countedNames is:// &#123; 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 &#125;var myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd'];var myOrderedArray = myArray.reduce(function (accumulator, currentValue) &#123; if (accumulator.indexOf(currentValue) === -1) &#123; accumulator.push(currentValue); &#125; return accumulator&#125;, [])console.log(myOrderedArray); Array.push()/ .pop()/ .shift()/ .unshift() 方法 说明 返回值 push 向数组的末尾添加一个或多个元素 新的 length 属性值 pop 数组中删除最后一个元素 该元素的值(当数组为空时返回undefined) shift 从数组中删除第一个元素 该元素的值(当数组为空时返回undefined) unshift 将一个或多个元素添加到数组的开头 新的 length 属性值","tags":[{"name":"array","slug":"array","permalink":"https://liuchao0704.github.io/tags/array/"}]},{"title":"个人简历 | 持续更新","date":"2019-10-01T13:45:43.000Z","path":"2019/10/01/resume/","text":"个人简历 个人信息 姓名 刘超 联系方式 18552057721 邮箱 liuc0704@outlook.com 应聘职位 前端工程师/JS工程师 性别 女 出生年月 1991-07 户籍 无锡 婚姻状况 未婚 学历 本科 毕业院校 南京信息工程大学 专业 电子信息技术 到岗时间 1个月 概要 精通HTML/CSS 精通JavaScript 精通 AngularJS 熟悉WEB应用开发技术，熟悉JavaScript技术平台，丰富的B/S框架项目开发经验 良好的英语技能 对研发及团队管理十分感兴趣。工作态度认真仔细，做事严谨，自信心强并且自我要求严格，为人开朗热情，具有团队意识，具有很好的沟通能力 参与过的Web项目 项目 角色 乐伏光伏大数据智慧管理平台 前端工程师 中国航天可再生能源管理平台 前端工程师，项目负责人 江西省光伏扶贫大数据平台 前端工程师 光伏运维管理平台 前端工程师 后端 JAVA+Tomcat+mybatis+spring+mysql 前端 AngularJS 乐伏光伏大数据智慧管理平台 负责：前端页面CSS/DIV编写，JS编写，整体负责前端框架。采用前后端完全分离的架构。前端采用AngularJS框架，通过AJAX请求与后端交互；同时引入百度地图插件和highcharts图表插件来丰富网站内容。 参与过的App项目 项目 角色 乐伏管家APP 前端工程师 乐伏监控APP 前端工程师 乐伏运维APP 前端工程师 前端 AngularJS 乐伏管家App 负责：前端页面CSS/DIV编写，JS编写，整体负责前端框架。采用前后端完全分离的架构。前端采用AngularJS框架，通过AJAX请求与后端交互；同时引入betterscroll插件, 它可以优化WebApp的滚动体验，使webApp中超长页更接近原生App的滚动效果。 工作经验 公司：江苏乐伏能源科技有限公司 时间：2016/11 – 至今 职位：前端工程师 汇报对象：部门经理 2016至今我在无锡乐伏能源有限公司从事前端开发。乐伏能源是一家光伏监控与运维解决方案的提供商。我有幸在公司创业之初就加入。经历了从无到有，初代产品研发以及后期功能的升级和迭代。主要为公司开发PC端网页系统以及移动端webApp。 项目经验乐伏智能光伏管理云中心3.0 无锡乐伏智慧光伏监控平台是一款为安装商/厂家用户量身制定的大屏软件。该产品方便用户查看电站运行情况、电站收益、设备运行状况、电站运维记录等信息。 本人在该项目中担任前端开发。HTML + CSS 制作高保真静态页面。使用AngualrJS + ajax 调用后台API接口获取数据并绑定到页面。 中国航天智慧能源管理平台 （Aerospace smart energy management system ） 中国航天智慧能源管理平台是为上海航天定制开发的大屏监控系统（适合2560x1440以上分辨率）于2018年8月上线。 本人负责该项目的前期沟通/需求整理/界面风格确认工作 分析客户基本需求：资产管理 、能量管理。结合公司现有系统功能提炼并改造 为中国航天开发了去菜单化一键查看数据流程。满足了非专业人士也能便捷操作能源站系统的需求。 本人在该项目中担任前端开发，HTML + CSS 制作高保真静态页面。使用AngualrJS + ajax 调用后台API接口获取数据并绑定到页面。 乐伏管家App 乐伏管家App可以同时满足个人业主和大型安装商对电站运营情况的查询和运维需求。2018年3月上线。 本人负责该项目产品需求整理和前端开发工作。采用AngularJs + betterscroll。betterscroll是一款优秀的滚动插件，它可以优化WebApp的滚动体验，使webApp中超长页更接近原生App的滚动效果。 视觉层面：根据电站的天气情况个性化设置页面，新增晴天/阴天/多云/雨/雪/夜间模式并动态更新页面，带来不一样的视觉体验 数据存储：利用AngularJs 的$rootscope作为简易版本的根数据管理，在$rootscope创建根对象用于存储多次复用并且实时更新的数据。 乐伏运维App 乐伏运维App可以满足终端业主及运维人员对于电站运维的需求。2017年9月上线。 本人负责该项目的前端开发工作。 AngularJs + ajax与后台交互数据 版本合一 android 和 ios 共用一个前端版本，减少维护成本。 路由切换更加自然 更接近原生app 乐伏运维系统网页版 乐伏电站运维系统网页版是一款为终端业主/运维人员/电站集成商打造的电站运维系统 。于2017年8月上线。 本人负责该项目的前端开发工作。乐伏运维系统采用AngualrJs框架将三种不同的电站管理角色紧密联系到一起，便于及时排除和解决电站的故障问题。 不同用户角色不同权限的页面展示 集成简易的物料管理系统，运单不同状态下的可操作流程、功能 乐伏电站设计系统网页版 乐伏电站设计系统是一款实用的电站设计系统。于2017年3月份上线。 本人负责该项目的前端开发工作。乐伏电站设计系统采用AngualrJs框架。该软件方便用户进行电站预估计算及设备选型。用户无需要专业的电站知识即可进行一键式计算收益和组件、设备匹配，使电站获得最佳收益。 高德地图支持用户快速自定义电站位置 ,获取该地理位置的辐照量和最佳倾斜角 乐伏电站监控系统网页版 乐伏监控系统网页版是一款功能丰富的电站监控系统，于2017年1月上线 。 本人负责该项目的前端开发工作。项目中使用AngularJs + bootstrap 框架。 AngularJs 负责数据双向绑定，ng-router路由开发SPA，使页面之间的切换效果更为流畅。使用图表类插件highcharts进行数据可视化，更加清晰的展示电站及设备的各个时间段发电量/功率/告警记录。 bootstrap 栅格系统快速搭建后台管理系统页面 教育经历 2009/09-2013/07 南京信息工程大学 电子信息技术 本科 薪资 目前薪资 12000 * 12 （税前） 语言能力 口语 书面 英语 一般 一般 中文 熟练 熟练 证书 类别 时间 名称 英语 2010-06 CET-6 计算机 2011-03 计算机二级 计算机 2012-09 计算机四级","tags":[{"name":"简历","slug":"简历","permalink":"https://liuchao0704.github.io/tags/简历/"}]},{"title":"前端面试总结","date":"2019-08-02T13:45:43.000Z","path":"2019/08/02/test/","text":"持续更新自我学习 Html5,CSS3 新特性html5 增加了一些新元素更符合语意化&lt;header&gt;&lt;/header&gt;,&lt;nav&gt;&lt;/nav&gt;,&lt;footer&gt;&lt;/footer&gt;,&lt;video &gt;&lt;/video&gt;html5 canvas ，拖拽，应用缓存css3 选择器，动画，渐变，过渡，border，盒模型，flex布局。 父级中的子元素上下左右局中 flex 布局 position:absoulte 123456/*flex 布局*/.parent&#123; display: flex; align-items: center; // 垂直 交叉轴 justify-content: center; // 水平 主轴方向 &#125; MVC 和 MVVM MVC M — Model 数据模型、数据源 V — View 视图层、界面 C — Controller 控制层、逻辑处理 用户操作view，view将改变传入controller，controller修改model，model将修改同步到view MMVM M — Model 数据模型、数据源 V — View 视图层、界面 VM — View-Model 是View和Model的桥接 举例Vue中，view通过事件绑定(DOM Listeners)操作model，model通过数据绑定(Data Bingdings)操作view Jquery和VUE 数据和视图的分离，解耦(开放封闭原则) 数据驱动视图，只需关心数据变化，DOM操作被封 模块化 为什么使用模块化，不使用模块化会怎么样 代码中的函数必须是全局变量才能使用给使用方带来全局变量的污染 js文件中的互相引用关系混乱 使用模块化不会暴露全局变量，自动引用依赖 AMD （Asynchronous Module Definition，即异步模块加载机制） AMD 典型代表 require.js 全局define 函数 全局require 函数 依赖JS会自动、异步加载 CommonJS nodejs模块化规范，前端大量使用 前端开发依赖的插件和库，都可以从npm中获取 构建工具的高度自动化 CommonJS 不会异步加载JS，而是同步一次性加载出来。 ES6 模块化 JS中的强制转化和隐式转化 强制转化 String（），Number（），Boolean（） 隐式转化 ，== 加减运算 关系操作符 逻辑操作符 Vue 取消事件冒泡 vue取消事件冒泡vue取消事件冒泡 vue阻止默认事件&lt;div @click.prevent=&quot;doSomething($event)&quot;&gt;vue阻止默认事件&lt;/div&gt; js 防止冒泡和捕获w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true 取消默认事件w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false; angularJS 双向数据绑定的实现AngularJs 为 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view(html) 上时 AngularJs 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发。$digest 会遍历所有的 $watch。从而更新DOM。 HTML5中的datalist是什么datalist 是HTML5 的新的表单元素 datalist要结合input元素才行，给input提供可用数据源不需要手动输入，加快输入，而且datalist还可以达到模糊匹配的效果。 本地存储和cookie之间的区别是什么https://segmentfault.com/a/1190000015929184 数据有效期不同： 默认情况下cookie只在浏览器会话期存在.退出浏览器就丢失;可以用expires设置时间;退出浏览器后就不会丢失并存为客户端浏览器的cookie文件;过了时间后cookie失效,还会自动删除cookie文件. sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了 localStorage 始终有效，长期保存。 存储大小 cookie历史悠久,浏览器支持率高。数据不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 作用域 相同浏览器的不同页面间可以共享相同的 localStorage(页面属于相同域名和端口，同源策略)，但是不同页面或标签页间无法共享sessionStorage的信息 cookie也是在所有同源窗口中都是共享的 cookie的path属性:默认情况下,在同一个目录下文件可以调用; 例如:http://demo.com/c1/1.html 设置的cookie可以被http://demo.com/c1/2.html调用.但不能被http://demo.com/c2/ 目录下的文件调用; 但如把path属性设成”/“;则在http://demo.com/ 下的所有文件都可调用此cookie. cookie的domain属性:例如设成”.demo.com”则在.demo.com(“http://a.demo.com&quot; 和 “http://b.demo.com&quot;)下的所有服务器下的文件都可以调用cookie. WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。 link 和 @import的区别是1.从属关系区别@import是 css 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 css 文件，还可以定义 RSS、rel 连接属性等。 2.加载顺序区别加载页面时，link标签引入的 css 被同时加载；@import引入的 css 将在页面加载完毕后被加载。 3.兼容性区别@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。 CSS选择器有哪些，哪些属性可以继承，优先级如何优先级 0,1,0,0 id选择器 优先级 0,0,1,0 类选择器 属性选择器 伪类选择器 :link 优先级 0,0,0,1 元素选择器 伪元素选择器 后代选择器 子元素选择器 相邻兄弟选择器 优先级 0,0,0,0 通配选择器*对特殊性没有贡献，即0,0,0,0。 可以继承的属性 color,line-height,font-size 补充 优先级 1,0,0,0 行间样式的特殊性是1,0,0,0 最后比较特殊的一个标志!important(权重)，它没有特殊性值，但它的优先级是最高的，为了方 便记忆，可以认为它的特殊性值为1,0,0,0,0。 html5中的应用缓存是什么应用程序缓存是专门从浏览器的缓存中分出一块缓存区用于缓存数据，从而在离线状态下也能读取和使用该数据，这就是应用缓存，或者说叫appcache 用Javascript创建一个对象工厂模式类似于普通函数调用 内部显式的创建对象 并且return 。工厂模式解决了创建多个相似对象的问题，但是没有解决对象识别的问题。 构造函数模式 没有显示的创建对象 直接属性和方法赋给了this对象 函数名大写 调用函数的时候用new 原型模式1234567891011121314151617181920212223242526272829// 工厂模式function createObj(name,age) &#123; var o = new Object(); o.name = name; o.age = age; return o;&#125;var obj1 = createObj('l',1);var obj2 = createObj('c',2);// 构造函数function CreateObj(name,age) &#123; this.name = name; this.age = age; // return this; // 默认return this&#125;var obj3 = new CreateObj('L',1);var obj4 = new CreateObj('C',2);// 原型模式function PrototypeCreateObj() &#123;&#125;PrototypeCreateObj.prototype.name = 'demo';PrototypeCreateObj.prototype.age = 18;var obj5 = new PrototypeCreateObj();var obj6 = new PrototypeCreateObj(); 事件循环机制https://blog.csdn.net/woleigequshawanyier/article/details/86371850 find(),fileter(),map(),forEach 和 for 循环的区别JavaScript 中 forEach、map、filter 终极篇 find()方法主要用来返回数组中符合条件的第一个元素(如果没有则返回undefined) filter()方法主要用来筛选数组中符合条件的所有元素，并且放在一个新数组中，如果没有，返回一个空数组 forEach()方法也是用于对数组中的每一个元素执行一次回调函数，但它没有返回值(或者说它的返回值为undefined，即便我们在回调函数中写了return语句，返回值依然为undefined。forEach不可以使用break，continue和return语句forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了(例如使用 shift()) ，之后的元素将被跳过。for循环可以使用break、continue和return语句 map()方法主要用来对数组中的每一个元素执行一次回调函数，并且把处理结果映射到一个新数组中返回(如果没有返回值，新数组中的每一个元素都为undefined)使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。和 forEach 一样 从输入url到页面渲染发生了几步？ 加载资源的形式 输入url(跳转一个路由) 加载html 加载html中依赖的静态资源 加载一个资源的过程 浏览器根据DNS服务器得到域名的IP地址 向这个IP的服务器发送http/https请求 服务器收到、处理并返回http请求 浏览器得到返回内容 浏览器渲染页面的过程 根据HTML结构生成DOM Tree 根据CSS 生成 CSSOM 将DOM和CSSOM 整合形成RenderTree 根据RenderTree 开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 window.onload 和 DomContentLoaded onLoad是的在页面所有文件加载完成后执行 DomContentLoad是Dom加载完成后执行，不必等待样式脚本和图片加载 浏览器的回流和重绘 重排也叫回流重排一定会引起重绘 重绘重绘不一定引起重排 性能优化 加载页面和静态资源 静态资源的压缩合并(webpack构建工具合并) 静态资源缓存 使用CDN让资源加载更快(CDN简单来说不同区域的优化) 使用SSR后端渲染(服务端渲染)，数据直接输出到HTML中 页面渲染 CSS放前面，JS放底部 懒加载(分批加载内容) 减少DOM查询，对DOM查询做缓存 减少DOM操作，多个操作进来合并在一起 事件节流/防抖 什么是跨域问题，如何解决？ 浏览器同源策略 (协议、端口、域名)同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 如何解决？ script标签 ，link标签 ，img标签都可以跨域 &lt;img&gt;用于打点统计，统计网站可能是其他网站 &lt;img&gt;,&lt;link&gt;可以使用CDN，CDN是其他域 JSONP原理 利用script标签可以跨域。 服务器端设置 http header 反向代理。 安全性能 XSS 跨站脚本攻击 用户输入内容里面包含代码&lt;script&gt; 执行，前端/后端替换转译字符 CSRF/XSRF 跨站请求伪造 增加验证流程","tags":[{"name":"面试","slug":"面试","permalink":"https://liuchao0704.github.io/tags/面试/"}]},{"title":"黄帝内经-素问-上古天真论-01","date":"2019-04-05T05:35:59.000Z","path":"2019/04/05/hdnj-sw01/","text":"关于黄帝内经的F&amp;Q 中医基本理论 昔在黄帝，生而神灵，弱而能言，幼而徇齐，长而敦敏，成而登天。何为上古天真论？道家讲求道法自然，中医是另外一种认识世界的方式。不怕中医是伪科学，就怕科学是伪真理。上古与人为（伪）相对，是接近自然的一种状态。学习中医需要我们回归自然，接近传统。神 亦非幡动，亦非风动，仁者心动。心亦是神 （god 造物主，who created everything）靈 包含巫 ，巫上下代表天地，左右代表活人与死人。巫是沟通天地活人死人的媒介，最开始的巫为女性，因为巫需要是很感性的人。当巫开始念咒语，雨下起来了，那么就灵验了。智慧 急中生智，静极生慧。智是小智，不动心，肉眼凡胎能研究的学问是智。慧含有心，心通神。双丰代表极大的智慧。言 立功立德立言，言并非随口说的话，而是能够出口成章，口传心授经典的话。黄帝自有天赋，年轻的时候酉得到高人和名师的提携。敦敏 中医讲究虚心实腑，修行到一定程度（道家的四重境界 真-至-圣-贤）。真人游行于天地之间，视听于四通八达。 乃问于天师曰：余闻上古之人，春秋皆度百岁，而动作不衰上古 女娲伏羲年代，距离黄帝还要久远的年纪。動 动的繁体字，人老先老脚。重字代表脚后跟。动作不衰，腿脚灵便，气血充足。 今时之人，年半百而动作皆衰者，时世异耶？人将失之耶岐伯对曰：上古之人，其知道者，法于阴阳，和于术数，食饮有节，起居有常，不妄作劳，故能形与神俱，而尽终其天年，度百岁乃去。道法 道是天道，法式人定的。術 人用于谋生的手段，古代对于工作/谋生的手段有着严格的要求，要对身心有益。数 数字也有阴阳，1，3，5，7，9是阳，2，4，6，8是阳。节 有节制，人吃到好吃的东西/好喝的东西都会不停的享受。这种欲望不加控制也就是纵欲。节欲不是禁欲也不是纵欲。饥饿，饥是胃肠恐龙，饿是内心感受，主观想进食。饮食要顺应天时，也要顺应内心的感受。吃饭快的人欲望比较强，心火旺，心神躁动。水是伤寒之物。","tags":[{"name":"中医","slug":"中医","permalink":"https://liuchao0704.github.io/tags/中医/"}]},{"title":"Vue使用总结","date":"2019-01-19T12:42:16.000Z","path":"2019/01/19/vue/","text":"根据最近所写vue项目总结之 父子组件通信 父组件向子组件传值通信 props 12345678910111213141516171819202122232425262728293031323334 //父组件：parent.vue&lt;template&gt; &lt;p&gt; &lt;child :vals = \"msg\"&gt;&lt;/child&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;import child from \"./child\";export default &#123; data()&#123; return &#123; msg:\"我是父组件的数据，将传给子组件\" &#125; &#125;, components:&#123; child &#125;&#125;&lt;/script&gt;//子组件：child.vue&lt;template&gt; &lt;p&gt; &#123;&#123;vals&#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:&#123; //父组件传值 可以是一个数组，对象 vals:&#123; type:String,//类型为字符窜 default:\"123\" //可以设置默认值 &#125; &#125;,&#125; 子组件向父组件传值通信 $emit 123456789101112131415161718192021222324252627282930313233343536373839404142434445//父组件：parent.vue&lt;template&gt; &lt;p&gt; &lt;child v-on:childevent='wathChildEvent'&gt;&lt;/child&gt; &lt;p&gt;子组件的数据为：&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;import child from \"./child\";export default &#123; data()&#123; return&#123; msg:\"\" &#125; &#125;, components:&#123; child &#125;, methods:&#123; wathChildEvent:function(vals)&#123;//直接监听 又子组件触发的事件，参数为子组件的传来的数据 console.log(vals);//结果：这是子组件的数据，将有子组件操作触发传给父组件 this.msg = vlas; &#125; &#125;&#125;&lt;/script&gt;//子组件：child.vue&lt;template&gt; &lt;p&gt; &lt;input type=\"button\" value=\"子组件触发\" @click=\"target\"&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; texts:'这是子组件的数据，将有子组件操作触发传给父组件' &#125; &#125;, methods:&#123; target:function()&#123; //有子组件的事件触发 自定义事件childevent this.$emit('childevent',this.texts);//触发一个在子组件中声明的事件 childEvnet &#125; &#125;,&#125; 父组件调用子组件方法 $refs.methodName(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//父组件：parent.vue&lt;template&gt; &lt;p&gt; &lt;child v-on:childevent='wathChildEvent' ref=\"childcomp\"&gt;&lt;/child&gt; &lt;input type=\"button\" @click=\"parentEnvet\" value=\"父组件触发\" /&gt; &lt;p&gt;子组件的数据为：&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;import child from \"./child\";export default &#123; data()&#123; return&#123; msg:\"\" &#125; &#125;, components:&#123; child &#125;, methods:&#123; wathChildEvent:function(vals)&#123;//直接监听 又子组件触发的事件，参数为子组件的传来的数据 console.log(vals);//这是子组件的数据，将有子组件操作触发传给父组件 this.msg = vlas; &#125;, parentEnvet:function()&#123; this.$refs['childcomp'].target(); //通过refs属性获取子组件实例，又父组件操作子组件的方法触发事件$meit &#125; &#125;&#125;&lt;/script&gt;//子组件：child.vue&lt;template&gt; &lt;p&gt; &lt;!-- dothing..... --&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; texts:'这是子组件的数据，将有子组件操作触发传给父组件' &#125; &#125;, methods:&#123; target:function()&#123; //又子组件的事件触发 自定义事件childevent this.$emit('childevent',this.texts);//触发一个在子组件中声明的事件 childEvnet &#125; &#125;,&#125;&lt;/script&gt; 兄弟组件通信 利用bus方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//建立一个空的Vue实例,将通信事件挂载在该实例上//emptyVue.jsimport Vue from 'vue'export default new Vue()//兄弟组件a:childa.vue&lt;template&gt; &lt;p&gt; &lt;span&gt;A组件-&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; &lt;input type=\"button\" value=\"把a组件数据传给b\" @click =\"send\"&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;import vmson from \"./emptyVue\"export default &#123; data()&#123; return &#123; msg:\"我是a组件的数据\" &#125; &#125;, methods:&#123; send:function()&#123; vmson.$emit(\"aevent\",this.msg) &#125; &#125;&#125;&lt;/script&gt;//兄弟组件b:childb.vue&lt;template&gt; &lt;p&gt; &lt;span&gt;b组件,a传的的数据为-&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;import vmson from \"./emptyVue\"export default &#123; data()&#123; return &#123; msg:\"\" &#125; &#125;, mounted()&#123; vmson.$on(\"aevent\",(val)=&gt;&#123;//监听事件aevent，回调函数要使用箭头函数; console.log(val);//打印结果：我是a组件的数据 this.msg = val; &#125;) &#125;&#125;&lt;/script&gt;//父组件：parent.vue&lt;template&gt; &lt;p&gt; &lt;childa&gt;&lt;childa&gt; &lt;childb&gt;&lt;/childb&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;import childa from \"./childa\";import childb from \"./childb\";export default &#123; data()&#123; return&#123; msg:\"\" &#125; &#125;, components:&#123; childa, childb &#125;,&#125;&lt;/script&gt; vue生命周期函数 beforeCreate； created； beforeMount； mounted； beforeUpdate； updated； beforeDestroy； destroyed beforeCreate（创建前） 在数据观测和初始化事件还未开始 created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来 beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。 beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。 destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 created钩子每次加载完成后都可以重复执行；而mounted钩子只在页面第一次加载后才调用出来，只要el被加载过，之后的重复加载该页面就不会调用该钩子了；注意：mounted在整个实例生命内只执行一次 切换主题body 中添加 data-theme 属性 (当有插件的时候,部分元素为js动态添加 )body.className[data-theme]可以覆盖插件cssdata-theme 配合 window.localStorage防止刷新网页失效 打包后css顺序错乱解决方案：其实只需把在main.js中的bootsrpa的css 或者 element-UI引入放到app的引入之前","tags":[{"name":"vue","slug":"vue","permalink":"https://liuchao0704.github.io/tags/vue/"}]},{"title":"NodeJs搭建本地服务器之使用手机访问","date":"2019-01-01T12:24:16.000Z","path":"2019/01/01/nodejs/","text":"方便快捷的本地环境搭建亲测可用 node.js 本地服务 文件名 service.js 命令行 node service 手机端和pc端在同一个网络里面就可以互相访问了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var url = require(\"url\"), fs=require(\"fs\"), http=require(\"http\"), path = require(\"path\");http.createServer(function (req, res) &#123; var pathname=__dirname+url.parse(req.url).pathname; if (path.extname(pathname)==\"\") &#123; pathname+=\"/\"; &#125; if (pathname.charAt(pathname.length-1)==\"/\")&#123; pathname+=\"index.html\"; &#125; fs.exists(pathname,function(exists)&#123; if(exists)&#123; switch(path.extname(pathname))&#123; case \".html\": res.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); break; case \".js\": res.writeHead(200, &#123;\"Content-Type\": \"text/javascript\"&#125;); break; case \".css\": res.writeHead(200, &#123;\"Content-Type\": \"text/css\"&#125;); break; case \".gif\": res.writeHead(200, &#123;\"Content-Type\": \"image/gif\"&#125;); break; case \".jpg\": res.writeHead(200, &#123;\"Content-Type\": \"image/jpeg\"&#125;); break; case \".png\": res.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); break; default: res.writeHead(200, &#123;\"Content-Type\": \"application/octet-stream\"&#125;); &#125; fs.readFile(pathname,function (err,data)&#123; res.end(data); &#125;); &#125; else &#123; res.writeHead(404, &#123;\"Content-Type\": \"text/html\"&#125;); res.end(\"&lt;h1&gt;404 Not Found&lt;/h1&gt;\"); &#125; &#125;);&#125;).listen(3000);console.log(\"Server running at localhost\");","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://liuchao0704.github.io/tags/nodejs/"}]},{"title":"6、流的破坏与保护","date":"2018-11-15T08:05:55.000Z","path":"2018/11/15/cssworld-float/","text":"float相关属性。 5.1 魔鬼属性float6.1.1 float的本质与特性 包裹性 块状化并格式化上下文 破坏文档流 没有任何margin合并 6.1.2 float的作用机制 父级元素“高度塌陷” 行框盒子和浮动元素不可重叠性","tags":[{"name":"css","slug":"css","permalink":"https://liuchao0704.github.io/tags/css/"},{"name":"浮动","slug":"浮动","permalink":"https://liuchao0704.github.io/tags/浮动/"}]},{"title":"你不知道的JS(上)作用域","date":"2018-10-07T01:32:20.000Z","path":"2018/10/07/you-dont-know-js-scope/","text":"读【你不知道的js上】之后对作用域的理解和总结 1、作用域是什么在程序中需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量。这套规则被称为作用域。 1.1 编译原理对于Javascript来说，大部分情况下的编译发生在代码执行前的几微秒(甚至更短)的时间内。任何Javascript代码片段在执行前都要进行编译。 1.2 理解作用域1.2.1 演员表 引擎从头到尾负责整个Javascript程序的编译及执行过程。 编译器引擎最好的朋友之一，负责语法分析及代码生成等脏活累活。 作用域引擎的另一个好朋友，负责收集并维护由所有声明的标志符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标志符的访问权限。 1.2.4 引擎和作用域的对话 RHS查询 谁是赋值操作的源头， 取到它的原值 ，注重拿到值 LHS查询 赋值操作的目标是谁， 为它赋值， 注重赋值 1.3 作用域嵌套当一个块或者函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域(也就是全局作用域)为止。 2、词法作用域简单的来说，词法作用域就是定义在词法阶段的作用域。词法作用域是你在写代码时将变量和块作用域写在哪里决定的。编译的词法分析阶段基本能够知道全部的标志符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 3、函数作用域和块作用域3.1 函数中的作用域函数用作域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。 3.2 隐藏内部实现可以将变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。 规避冲突 全局命名空间 模块管理 3.3 函数作用域区分函数声明和表达式最简单的方法是看function关键字出现在声明的位置，如果function是声明的第一个词，那么就是一个函数声明，否则就是一个函数表达式。函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。 (function foo(){…})作为一个函数表达式意味着foo只能在…所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 3.3.1 匿名和具名匿名函数表达式最熟悉的场景就是回调参数 123setTimeout(function()&#123; console.log(1)&#125;,1000) 匿名函数表达式虽然书写起来简单快捷，但是也存在几个缺点 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性/可理解性很重要的函数名 3.3.2 立即执行函数表达式由于函数被包含在一对()括号内部，因此成为了一个表达式，通过在末尾加上另外一个( )可以立即执行这个函数。第一个( )将函数变成了表达式，第二个( )执行了这个函数。IIFE代表立即执行函数表达式(Immediately Invoked Function Expression)。 1234(function ITFE() &#123; var a = 2; console.log(a) //2&#125;)(); IIFE的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。 1234567var a = 2;(function ITFE(global) &#123; var a = 3; console.log(a) //3 console.log(global.a) //2&#125;)(window); console.log(a) //2 3.4 块作用域表面上看JavaScript并没有块作用域的相关功能 3.4.2 try/catchJavascript的ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。1234567try &#123; undefined();&#125;catch (err) &#123; console.log(err)&#125;console.log(err);//ReferenceError: err is not defined ES6中引入了let，使得代码有了创建完整、不受约束的块作用域的能力。但是在ES6之前，或者慢慢的向ES6环境过渡期我们如何创建块作用域的效果？ 12345678910111213 &#123; let a = 2; console.log(2); &#125; console.log(a); //ReferenceError: a is not definedtry &#123; throw 2;&#125;catch (a) &#123; console.log(a)&#125;console.log(a); //ReferenceError: a is not defined 4、提升4.1 先有鸡还有蛋思考是声明(蛋)在前？还是赋值(鸡)在前？123456a = 2;var a ;console.log(a); //2console.log(b); //undefinedvar b = 2; 4.2 编译器再度来袭引擎会在解释Javascript代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。 包括变量和函数在内的所有的声明都会在任何代码被执行前首先被处理 函数声明会被提升，但是函数表达式却不会被提升 4.3 函数优先函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。 要注意避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候 作用域闭包5.2 启示当函数可以记住并访问所在的词法作用域时，就产生了闭包函数在定义时的词法作用域以外的地方被调用，但是依然持有对该作用域的引用。这个引用就是闭包。闭包主要例子模块","tags":[{"name":"scope","slug":"scope","permalink":"https://liuchao0704.github.io/tags/scope/"}]},{"title":"你不知道的JS系列之精读","date":"2018-08-07T01:32:20.000Z","path":"2018/08/07/you-dont-know-js-index/","text":"精读【你不知道的js】系列归纳总结目录 类型JavaScirpt 有七种内置类型 未定义——undefined 空值——null 布尔值——boolean 数字——number 字符串——string 对象——object 符号——symbol（es6 新增） 可以用typeof运算符查看值的类型，但是null有些特殊 123typeof null === 'object'; // true var a = null;(!a &amp;&amp; typeof a === 'object'); // true null是 \"假值\"也是唯一一个用typeof检测会返回\"object\"的基本类型值。 js中变量没有类型，只有变量所存储的值才有类型,可以使用typeof运算符查看。typeof在使用时候由于安全机制不能区分undefined(声明但是未赋值)和undeclared(未声明的变量) 12345var a;console.log(a) // undefinedconsole.log(typeof a) // undefinedconsole.log(typeof b) // undefinedconsole.log(b) // ReferenceError: b is not defined 值 数组 Array.of() Array.from() Array.copyWithin() Array.fill() Array,reduce() Array.reverse() 数组的增删拼接 字符串 String.concat() String.slice() String.substring() 数字 0.1 + 0.2 = 0.3 ？ 整数检测 NaN的判断 ±0 特殊等式 NaN !== NaN ,0 === -0 特殊数值 undefined null 原生函数强制类型转化作用域闭包this原型继承异步回调PromiseES6","tags":[{"name":"目录","slug":"目录","permalink":"https://liuchao0704.github.io/tags/目录/"}]},{"title":"5、内联元素与流","date":"2018-05-07T05:18:55.000Z","path":"2018/05/07/cssworld-line-height/","text":"line-height相关知识。 5.1 字母x–CSS世界中隐匿的举足轻重的角色5.1.1 字母x与CSS世界的基线字母x的下边缘是css世界的基线 5.1.2 字母x与CSS中x-height x-height: 小写字母x的高度也就是ex。ex是css中的一个相对单位。 vertical-align:middle middle是指基线往上1/2处x-height的高度。可以近似理解x交叉点的位置。 5.2 内联元素的基石5.2.1 内联元素的高度之本 ———— line-height line-height决定非替换元素的纯内联元素的可视高度。 内联元素的高度由固定高度和不固定的高度组成，这个不固定的高度就是指“行距”。 css中“行距”分散在当前文字的上方和下方，也就是第一行文字，其上方也是有“行距”的，不过高度是“行距”的一半，也叫做半“行距”。 行距 = line-height - font-size 对于替换元素来说line-height改变不了其高度 对于块级元素，line-height对其本身没有任何作用，我们改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面的内联级别元素占据的高度实现的。 5.2.2 为什么line-height可以让内联元素“垂直居中”line-height 设置的垂直居中，并不是真正意义上的垂直居中而是近似“垂直居中” 回答为何可以“垂直居中”，行高可以实现“垂直居中”原因在于css中“行距上下等分机制” “近似”是因为文字字形的垂直中线位置普遍要比真正的“行框盒子”的垂直中线位置低 实现多行文本或者替换元素的垂直居中需要line-height和vertical-align共同设置 1234567891011121314151617&lt;style&gt;.box &#123; width: 200px; line-height: 120px; background-color: #f0f0f9; &#125;.content &#123; display: inline-block; line-height: 20px; margin: 0 20px; vertical-align: middle; &#125;&lt;/style&gt; &lt;div class=\"box\"&gt; &lt;div class=\"content\"&gt;基于行高实现的。。。基于行高实现的。。。&lt;/div&gt; &lt;/div&gt; 多行文字使用一个标签包裹，然后设置display为inline-block。可以重置外部的line-height，还可以设置vertical-align属性，以及产生一个关键的“行框盒子”。由于每个“行框盒子”都会附带的产物——“幽灵空白节点”，有了这个节点，我们的line-height:120px就有了作用对象 因为内联元素默认都是基线对齐的，所以对.content元素设置vertical-align:middle来调整多行文本的垂直位置。 5.2.3深入line-height的各类属性值line-height 的默认值是normal，还支持数值，百分比值以及长度值。 数值 line-height:1.5，最终计算值 1.5*14px = 21px。 百分比值 line-height:150% ，最终计算值 150%*14px = 21px。 长度值 line-height:21px ，line-height:1.5em 最终计算值 1.5*14px = 21px。 如果line-height使用数值作为属性值，则所有子元素都是继承这个值。但是如果用百分比或者长度值作为属性值，那么所有子元素继承的都是最终的计算值。 5.2.4 内联元素line-height的“大值特性”无论内联元素元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的，内联元素line-height的“大值特性”123456789101112131415161718192021222324252627 &lt;div class=\"box\"&gt; &lt;span class=\"content\"&gt;基于行高实现的&lt;/span&gt; &lt;/div&gt; &lt;style&gt; .box &#123; width: 200px; line-height: 120px; background-color: #f0f0f9; &#125; .content &#123; line-height: 20px; margin: 0 20px; &#125;&lt;/style&gt;&lt;style&gt; .box &#123; width: 200px; line-height: 20px; background-color: #f0f0f9; &#125; .content &#123; line-height: 120px; margin: 0 20px; &#125;&lt;/style&gt; 5.3 line-height的好朋友vertical-align5.3.2 vertical-align作用的前提vertical-align作用的前提是只能应用于内联元素以及display值为table-cell的元素。浮动和绝对定位会让元素块状化。 vertical-align:middle 与近似垂直居中 父级line-height的值设置了空白幽灵节点的高度 line-height使得x近似垂直居中 子级vertical-align:middle使图片的垂直中心和x的1/2x-height靠近。随着字体的设置，x字符的中心点其实是靠下的。","tags":[{"name":"css","slug":"css","permalink":"https://liuchao0704.github.io/tags/css/"},{"name":"line-height","slug":"line-height","permalink":"https://liuchao0704.github.io/tags/line-height/"},{"name":"vertical-align","slug":"vertical-align","permalink":"https://liuchao0704.github.io/tags/vertical-align/"}]},{"title":"4、盒尺寸四大家族","date":"2018-05-06T05:18:37.000Z","path":"2018/05/06/cssworld-box/","text":"深入理解content/padding/margin 4.1 深入理解content4.1.1 contnet 与替换元素什么是替换元素通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。典型的替换元素 &lt;img&gt;,&lt;object&gt;,video,&lt;iframe&gt;,&lt;textarea&gt;,&lt;input&gt; 内容外观不受页面上的css的影响 有自己的尺寸 在很多css属性上有自己的一套表现规则 替换元素的默认的display值所有的替换元素都是内联水平元素。替换元素的display值对于其尺寸计算规则无影响。 替换元素的尺寸计算规则替换元素的尺寸：固有尺寸、HTML尺寸、CSS尺寸 如果没有CSS尺寸和HTML尺寸则使用固有尺寸作为最终的宽高 如果没有CSS尺寸则使用HTML尺寸 如果存在CSS尺寸，则最终尺寸由CSS属性决定 如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或者仅设置了高度，则元素依然按照固有的宽高比例显示。 如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。宽高比2:1。 内联替换元素和块级替换元素使用上面同一套尺寸计算规则。 替换元素和非替换元素的距离 替换元素如img去掉src属性则是普通非替换元素。 12345678&lt;style&gt;img &#123;display: block;border: 1px solid #eee;&#125;&lt;/style&gt;&lt;!-- alt为任意值 --&gt;&lt;img alt=\"1\"&gt; 此时img的宽度100%自适应父级容器 非替换元素和替换元素只隔了一个CSScontent属性 1234567h1 &#123;content: url(../th.jpg);width: 50px;height:50px;&#125;&lt;!-- 普通元素content --&gt;&lt;h1&gt;图片&lt;/h1&gt; 此时h1就是一个50*50的图片 4.2 温和的padding属性4.2.1 padding与元素尺寸内联元素的padding在垂直方向同样会影响布局。垂直方向会发生层叠。利用这一特点可以优雅的增加点击区域同时对现有布局无任何影响。 4.2.2 padding的百分比值padding百分比值无论是水平方向还是垂直方向均是相对于父级宽度来计算。 实际使用实例可以做自适应的等比矩形。 12345678910111213141516&lt;style&gt; .img-wrapper &#123; position: relative; padding: 50%; //实现正方形 &#125; .img-wrapper &gt; img &#123; position: absolute; width: 100%; height: 100%; left:0; top:0; &#125;&lt;/style&gt; &lt;div class=\"img-wrapper\"&gt; &lt;img src=\"../th.jpg\" alt=\"1\" &gt;&lt;/div&gt; 内联元素的padding padding相对宽度计算 默认的高度的宽度细节有差异 padding 会断行 4.3 激进的margin属性4.3.1 margin与元素尺寸以及相关布局 margin 与元素的内部尺寸 marign改变元素的可视尺寸与padding相反。对于paddding，元素设定了width属性或者保持包裹性的时候，会改变元素可视尺寸。而margin则无视之，只有当元素是“充分利用可用空间”状态的时候，margin才可以改变元素的可视尺寸。 12345678910111213141516171819&lt;style&gt;.father &#123;padding:0 10px ;&#125;.son &#123;margin: 0 -10px;line-height: 20px;text-align: center;background-color:#e1e1e1;&#125;&lt;/style&gt;&lt;body&gt;&lt;!-- marigin 改变子级宽度 --&gt;&lt;div class=\"father\"&gt;&lt;div class=\"son\"&gt;barfoo&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 4.3.4 深入理解CSS中的margin:auto触发margin:auto计算有个前提条件就是width或者height为auto时，元素是具有对应方向的自动填充特性。(比如块状元素的width默认100%继承父级，绝对定位元素的格式化宽度和高度)marigin:auto的填充规则 如果一侧定值,一侧auto,则auto为剩余空间。 如果两侧均是auto,则平分剩余空间。 针对第一条可以实现块状元素的左右对齐(而不是只有通过float:left/right) 例子（利用content生成伪元素以及margin:auto实现常见布局）123456789101112131415161718192021222324252627282930313233343536 &lt;style&gt; .home-icon-item:after &#123; position: absolute; display: inline-block; content: ''; width: 50px; height: 50px; left: 0; top: 0; right: 0; bottom: 0; margin: auto; border-radius: 50%; z-index: -1; &#125; &lt;/style&gt; &lt;div class=\"home-icon-wrapper\"&gt; &lt;div class=\"home-icon-item\"&gt; &lt;i class=\"iconfont\"&gt;1&lt;/i&gt; &lt;span class=\"text\"&gt;培训&lt;/span&gt; &lt;/div&gt; &lt;div class=\"home-icon-item\"&gt; &lt;i class=\"iconfont\"&gt;2&lt;/i&gt; &lt;span class=\"text\"&gt;会议&lt;/span&gt; &lt;/div&gt; &lt;div class=\"home-icon-item\"&gt; &lt;i class=\"iconfont\"&gt;3&lt;/i&gt; &lt;span class=\"text\"&gt;学员服务&lt;/span&gt; &lt;/div&gt; &lt;div class=\"home-icon-item\"&gt; &lt;i class=\"iconfont\"&gt;4&lt;/i&gt; &lt;span class=\"text\"&gt;资料下载&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 4.4功勋卓越的border属性4.4.3 border-color和colorborder-color 有一个很重要也很实用的特性，就是“border-color默认颜色就是color色值”。根据这个特性可以做个简单的边框hover变色实例。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .border &#123; position: relative; width: 80px; height:80px; border:2px dashed; color: #e3e3e3; &#125; .border:hover &#123; color:red; &#125; .border::after &#123; position: absolute; display: block; content: ''; width:40px; height: 40px; border-top:6px solid; top:40px; left:40px; margin-top: -3px; margin-left: -20px; &#125; .border::before &#123; position: absolute; display: block; content: ''; width:40px; height: 40px; top:40px; left:40px; margin-top: -20px; margin-left: -3px; border-left:6px solid; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- border属性缺省 --&gt; &lt;div class=\"border\"&gt; &lt;/div&gt;&lt;/body&gt; 例子（利用border和margin实现等分布局） 12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .bg &#123; padding: 15px 30px; background-color: #e1e1e1; &#125; .ul-wrapper &#123; padding-left: 0; margin-right: -15px; &#125; .ul-wrapper::after &#123; display: block; content: ''; clear: both; &#125; .li-item &#123; float: left; width:25% ; box-sizing: border-box; border-right: 15px solid transparent; list-style-type:none; background-color: #8BC34A; background-clip: content-box; //content-box可以减少嵌套 height: 150px; &#125;&lt;/style&gt; &lt;!-- margin 等分布局 --&gt; &lt;div class=\"bg\"&gt; &lt;p &gt;管理中心&lt;/p&gt; &lt;ul class=\"ul-wrapper\"&gt; &lt;li class=\"li-item\"&gt;&lt;/li&gt; &lt;li class=\"li-item\"&gt;&lt;/li&gt; &lt;li class=\"li-item\"&gt;&lt;/li&gt; &lt;li class=\"li-item\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 两种等高布局 border margin + padding 12345678910111213141516171819202122232425262728293031323334&lt;style&gt;.border-box &#123; margin: 10px 0; border-left:150px solid #c7c7c7; background-color: #f1f1f1; &#125;/* 此处不能用overflow:hidden清除浮动否则左浮动的导航列表元素就会被隐藏掉 */.border-box::after &#123; display: block; content: ''; clear: both;&#125;.border-box &gt; nav &#123; width: 150px; margin-left: -150px; float: left; text-align: center; &#125;&lt;/style&gt; &lt;!-- border等高布局--&gt;&lt;div class=\"border-box\"&gt; &lt;nav&gt; &lt;h3&gt;导航1&lt;/h3&gt; &lt;h3&gt;导航2&lt;/h3&gt; &lt;/nav&gt; &lt;section&gt; &lt;h5&gt;模块1&lt;/h5&gt; &lt;h5&gt;模块2&lt;/h5&gt; &lt;h5&gt;模块3&lt;/h5&gt; &lt;/section&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728 &lt;style&gt; .margin-box &#123; overflow: hidden; &#125; .column-left ,.column-right &#123; width: 50%; float: left; padding-bottom: 9999px; margin-bottom: -9999px; &#125; .column-left &#123; background-color: #c7c7c7; &#125; .column-right &#123; background-color: #f1f1f1; &#125;&lt;/style&gt; &lt;!-- margin + padding 等高布局 --&gt;&lt;div class=\"margin-box\"&gt; &lt;div class=\"column-left\"&gt; &lt;h3&gt;导航1&lt;/h3&gt; &lt;h3&gt;导航2&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"column-right\"&gt; &lt;h4&gt;模块1&lt;/h3&gt; &lt;/div&gt;&lt;/div&gt;","tags":[{"name":"css","slug":"css","permalink":"https://liuchao0704.github.io/tags/css/"}]},{"title":"3、流、元素、基本尺寸","date":"2018-05-06T05:18:25.000Z","path":"2018/05/06/cssworld-width/","text":"认识各种盒子以及width/height作用细节 3.1 块级盒子（认识各种盒子）根据整个第三章第四章以及第五章的内容，将盒子模型之间的关系画了一个总的示意图。 3.2 width/height 作用的具体细节3.2.1 width:auto属性 充分利用可用空间 &lt;div&gt; ,&lt;p&gt;这些元素默认宽度100%充满父级 （外部尺寸） 收缩与包裹性 （内部尺寸） 收缩到最小 （内部尺寸） 超出容器限制 （内部尺寸） “外部尺寸”与“内部尺寸” 外部尺寸：宽度由外部元素决定 内部尺寸：宽度由内部元素决定 如果一个元素里面没有内容宽度为0， 那么这个元素应用的就是“内部尺寸” 外部尺寸与流体特性 正常流宽度在页面中随便扔一个&lt;div&gt;元素，其尺寸表现就会和这水流一样铺满容器，这就是block容器的流特性。 格式化宽度格式化宽度仅出现在“绝对定位模型”中，也就是出现在position:absolute，position:fixed中。一般来说绝对定位元素的宽度是包裹性的，由内部元素决定。但是对于非替换元素当left/top 或者top/bottom对立方的属性值同时存在的时候，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定特性的祖先元素计算。“格式化宽度”具有完全的流体性，也就是margin、border、padding和content内容区域同样会自动分配水平（垂直）空间。 内部尺寸与流体特性 包裹性“包裹性”包含“包裹”以及“自适应性”。自适应性是指元素尺寸由内部元素的宽度决定，但是永远小于“包含块”容器的尺寸(除非容器尺寸小于元素的“首选最小宽度”)。除了inline-block元素，浮动元素以及绝对定位元素都具有包裹性。 首选最小宽度所谓“首选最小宽度”，指的是元素最合适的最小宽度。如果外部容器宽度是0，内部inline-block元素宽度不会为0。 最大宽度实际等同于“包裹性”元素设置white-space:nowrap声明后的宽度。如果内部没有块级元素或者块级元素没有设定宽度值，则“最大宽度”实际上是最大的连续内联盒子的宽度 3.2.2 width值作用的具体细节 width作用在content box上 3.2.3 CSS流体布局下的宽度分离原则 不在同一层标签上设置width，padding。 width设置在父级标签上，子级标签设置padding,border属性。子级自适应父级宽度。 3.2.4 改变width作用细节的box-sizing box-sizing被发明的初衷更大的可能是解决替换元素宽度自适应问题。原因替换元素的尺寸由内部元素决定对于其设置display属性是inline还是block,替换元素的宽度都不会受其影响。当替换元素设置display:block是无法让元素100%自适应父级。所以让textarea的width100%自适应父级，同时保留border,padding属性只能通过box-sizing:border-box来解决 123 input ,textarea, img, video, object &#123; box-sizing: border-box&#125; 3.2.6 height: 100%如何让元素支持height:100%? 设定显示的高度 123 html, body &#123; height: 100%;&#125; 使用绝对定位 绝对定位元素百分比计算和非绝对定位元素的百分比计算是有区别的，区别在于绝对定位的宽高百分比计算是相对于padding box 3.3 CSSmin-width/max-width和min-height/max-height3.3.2 与众不同的初始值min-width/min-height的初始值为automax-width/max-height的初始值为none (思考为什么max的初始值为none 而不是auto) 3.3.3 超越!important 超越最大简单的来说min和max的权重比!important大。 如果min和max设置起冲突的时候。min-width 会覆盖max-width。","tags":[{"name":"css","slug":"css","permalink":"https://liuchao0704.github.io/tags/css/"}]},{"title":"css总结 | 读css世界笔记","date":"2018-04-16T07:04:25.000Z","path":"2018/04/16/cssworld-index/","text":"2018年2月份入手了《css世界》一书。打算过年内看完，但是翻阅之后决定作为工具书多次阅读并记笔记总结之，加深自己对css的理解。随着页面越来越个性化，我发现写一段易修改，可维护，代码量少的css相当重要。 3 、流、元素、基本尺寸4、盒尺寸四大家族 5、内联元素与流 6、流的破坏与保护","tags":[{"name":"目录","slug":"目录","permalink":"https://liuchao0704.github.io/tags/目录/"}]},{"title":"游泳小记","date":"2018-04-09T12:42:16.000Z","path":"2018/04/09/swim/","text":"觉得为时已晚的时候,恰恰是最早的时候 Day1 （2018.04.09）一共十节课 今天是第一节。课时一个小时，主要学会了漂浮在水面、换气、手臂动作。刚开始入水我是恐惧的，不敢手臂远离墙壁，自身腰部也很紧张，腿部很沉，下半身很沉，总是飘不起来。就算勉强漂浮在水中，身体也极度不稳定，整个人像风雨中飘摇的船只，左右摇晃不定，容易翻身。对于这种情况，教练教了两种动作，一个是在水中自主站立的动作，双腿的膝盖靠近胸部，手臂向下挥舞 ，人就顺势站立起来。还有一种是感觉你要翻身的时候 ，脚尖绷紧，膝盖打直，手臂张开角度越大越好，手臂打直 ，手指尖绷紧。然后整个人就不容易翻身了。掌握了以后，就不怕对水的恐惧了。 开心ing。 Day2-5 （2018.04.10-04.13）整个四节课就练习划手和蹬腿，其中蹬腿的用的时间很长，我刚开始练习的时候犯了很多错误。 蹬腿必撅屁股 蹬腿身体滑行距离很小 蹬腿几次之后身体下半身越来越下沉 蹬腿像慢动作 首先蹬腿的时候 在小腿和脚后跟靠近屁股的同时，膝关节尽量打开 + 大腿不要太往池底靠，这样屁股就不会撅起来了。 蹬腿的时候 尽量保证身体的平稳性 不要操之过急，每次蹬腿完毕尽量让身体都稳定在水面中央 既不下沉的厉害，也不漂浮的厉害。 蹬腿要快要用力 Day6 （2018.04.15）今天蹬腿和划手有点感觉了，滑行的距离也出来了。明天可以练习一下综合了 Day1N (2018.05.06)应该练习了有十几天，五一假期三天连续练习，能游一个来回，但是蹬腿的距离太短，以至于不停的蹬腿才能保持前进。初步判断是人未达到平行的状态就蹬腿，导致一部分前进的力量被分解为向上的力量。后期注意蹬腿时机。","tags":[{"name":"游泳","slug":"游泳","permalink":"https://liuchao0704.github.io/tags/游泳/"}]},{"title":"常用正则表达式整理","date":"2018-02-01T13:45:43.000Z","path":"2018/02/01/reg/","text":"将常用的正则表达式整理如下。 常用正则表达式整理正则元字符 字符 描述 * 匹配前面的字表达式零次或者多次等价于{0,} + 匹配前面的字表达式一次或者多次等价于{1,} ? 匹配前面的字表达式零次或者一次等价于{0,1} 整数(不限制正负)1/^-?\\d+$/; // 不限制长度 整数(&gt; 0)12/^[1-9]\\d*$/; // 不限制长度/^[1-9]\\d&#123;0,5&#125;$/;// 限制长度 整数(&gt; 0 &amp;&amp; &lt;= 100)1/^(100|([1-9]&#123;1&#125;\\d?))$/ 浮点型(&gt; 0 保留2位小数)1/^(([1-9]&#123;1&#125;)(\\.\\d&#123;1,2&#125;)?|(0(\\.\\d&#123;0,1&#125;[1-9])))$/ 12/^(([1-9]&#123;1&#125;[0-9]&#123;0,5&#125;)(\\.\\d&#123;1,2&#125;)?|(0(\\.\\d&#123;0,1&#125;[1-9])))$/ 浮点型(&gt;= 0 保留2位小数)1/^(([1-9]&#123;1&#125;)(\\.\\d&#123;1,2&#125;)?|(0(\\.\\d&#123;0,1&#125;[1-9])?))$/ 字符串开头不能空格 中间可以是空格/数字/字母/中文/非特殊字符结尾1/^[\\w\\u4e00-\\u9fa5]&#123;1&#125;[\\s\\w\\u4e00-\\u9fa5]&#123;0,8&#125;$/","tags":[{"name":"正则","slug":"正则","permalink":"https://liuchao0704.github.io/tags/正则/"}]},{"title":"学以致用系列之Array","date":"2018-01-28T10:46:46.000Z","path":"2018/01/28/jsArray/","text":"改造一下之前ng中checkbox全选和选不选的js。 一行代码搞定Array的深拷贝12var data = data.conact(); // js contacat() 方法会返回一个新的数组。tips：原数组中如有对象,还是不能做到完全的深拷贝。var data = data.splice(); //同上 数组的过滤 filter()原来我操作的数组的思路是循环数组找到index,然后用数组的splice(index, 1)删除。其实就是filter()应该干的事情。 改写Angular JS动态控制多选框点击查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script src=\"angular-1.3.0.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=\"myApp\" ng-controller=\"vipApplyEditCtrl\"&gt;&lt;div&gt; &lt;input type=\"checkbox\" name=\"all\" ng-model=\"all\" ng-change=\"toSelectAll(all)\"&gt; 全选 &lt;i&gt;&#123;&#123;all&#125;&#125;&lt;/i&gt; &lt;div ng-repeat=\"color in colors\"&gt; &lt;input type=\"checkbox\" ng-checked=\"color.checked == true\" ng-click=\"updateSelection(color)\" /&gt; &#123;&#123;color.name&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;div&gt; Selected :&#123;&#123;selected&#125;&#125;&lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller(\"vipApplyEditCtrl\", function($scope) &#123; $scope.formData = &#123;&#125;; $scope.colors = [ &#123;id : 1, name : 'black'&#125;, &#123;id : 2, name : 'red'&#125;, &#123;id : 3, name : 'blue'&#125;, &#123;id : 4, name : 'yellow'&#125;, &#123;id : 5, name : 'green'&#125;, &#123;id : 6, name : 'white'&#125; ] ; $scope.selected = [] ; // 存放新的已选数据 $scope.updateSelection = function(obj)&#123; obj.checked = !obj.checked; $scope.selected = [] ; $scope.colors.forEach(function(item)&#123; if(item.checked)&#123; $scope.selected.push(item.id) ; &#125; &#125;) $scope.colors.every(function(item)&#123; return item.checked ; &#125;) &#125;; $scope.toSelectAll = function(flag)&#123; $scope.selected = []; $scope.colors.forEach(function(i)&#123; i.checked = flag; if(flag)$scope.selected.push(i.id); &#125;) &#125;&#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 一维数组分割成二维数组目的 将一维数组按照既定的目标个数截取变成二维数组 123456789101112131415161718192021222324252627282930 var totalNum = 23 ;// 初始化一维数组 var originArr = []; for (var i=0; i&lt; totalNum; i++) &#123; originArr.push(i) &#125; var result = []; // 存放结果 var index = 0; // 存放二维标志位 var targetNum = 11; // 希望截取的个数/* 方法一 index是一维变二维的关键标志位。 标志位和 Math.floor (j / targetNum ) 恰好相同 如果二维数组还未初始化，初始化二维数组为空数组待用。 标志位相同的个体都是同一个二维数组成员，push到同一个result[index]里面*/ for (var j=0; j&lt; originArr.length;j++) &#123; index = Math.floor (j / targetNum ) if(!result[index])&#123; result[index] = [] &#125; result[index].push(j) &#125;// 方法二for (var j=0; j&lt; originArr.length;j=j+targetNum)&#123; var curArr = originArr.slice(j,j+targetNum); result.push(curArr)&#125; console.log(result)","tags":[{"name":"checkbox","slug":"checkbox","permalink":"https://liuchao0704.github.io/tags/checkbox/"}]},{"title":"Sticky footer 布局","date":"2018-01-06T05:18:37.000Z","path":"2018/01/06/stickyfooter/","text":"css3的一种经典布局:footer紧紧粘在底部，当页面内容不足一页的时候，footer在最底部。当页面内容超过一页，footer自动在底部。 sticky footer 布局示意图 sticky-footer布局思路1父元素包裹内容，并给他一个内边距使其等于底部的高度，防止内容覆盖到底部的内容。底部元素有个负的margin值 css3 代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; html, body &#123; height: 100%; margin: 0; &#125; .wrapper &#123; min-height: 100%; &#125; .clearfix::after &#123; display: block; content: \".\"; height: 0; clear: both; visibility: hidden; &#125; .content-inside &#123; padding-top: 20px; padding-left: 20px; padding-right: 20px; padding-bottom: 50px; &#125; .content-inside&gt;p &#123; line-height: 60px; margin: 0; &#125; .footer &#123; height: 50px; margin-top: -50px; background-color: #00b3ee; text-align: center; color: white; font-size: 24px; line-height: 50px; &#125; &lt;/style&gt; div布局123456789101112131415161718 &lt;body&gt; &lt;div class=\"wrapper clearfix\"&gt; &lt;div class=\"content-inside\" id=\"div\"&gt; &lt;h1&gt;content&lt;/h1&gt; &lt;button onclick=\"addP()\"&gt;点击添加文字&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;footer class=\"footer\"&gt;footer&lt;/footer&gt; &lt;script&gt; var element = document.getElementById(\"div\"); function addP() &#123; var para = document.createElement(\"p\"); var node = document.createTextNode('这是一个新段落'); para.appendChild(node); element.appendChild(para); &#125; &lt;/script&gt;&lt;/body&gt; sticky footer 布局思路21234&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt;这里是主要内容&lt;/div&gt; &lt;div class=\"footer\"&gt;这是页脚区块&lt;/div&gt; &lt;/div&gt; 1234567891011.wrapper &#123; display: flex; flex-direction: column; min-height: 100vh;&#125;.content &#123; flex: 1;&#125;.footer &#123; flex: 0;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://liuchao0704.github.io/tags/css/"}]},{"title":"AngularJs开发webApp","date":"2017-07-07T13:45:43.000Z","path":"2017/07/07/ng-app/","text":"最近用angularJs做了一些webApp,也总结了不少的固定套路。现在将固定套路整理如下,主要分为css适配,js通信部分。 js部分$rootscope打造轻量级数据管理 建议将常量定义在 main.js 里的 $rootscope里,必要时结合$localstorage 使用。好处:一次定义,多次复用，实时更新 1234567891011121314151617181920212223var u = navigator.userAgent;$scope.app = &#123; errorId:null, //错误码 enableToAddEquip: false, //是否可以添加设备 environment: /localhost/.test(window.location.href) ? 'dev' : 'product', //开发or生产环境 logOut: false, //是否退出 isAndroid: u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1 || u.indexOf('Linux') &gt; -1, //判断安卓或者苹果 isIphone: u.indexOf('iPhone') &gt; -1, version: 1.0, weatherKey: 5, //天气状态码 roleName: $localStorage.app ? $localStorage.app.roleName : '', // 不在提示绑定 email: $localStorage.app ? $localStorage.app.email : '', // 终端用户 &amp; 安装商email userName: $localStorage.app ? $localStorage.app.userName : '', password: $localStorage.app ? $localStorage.password : '', installerSn: $localStorage.app ? $localStorage.app.installerSn : null, operationSn: $localStorage.app ? $localStorage.app.operationSn : null, userSn: $localStorage.app ? $localStorage.app.userSn : null, equipSn: $localStorage.app ? $localStorage.app.equipSn : null, stationId: $localStorage.app ? $localStorage.app.stationId : null, authError: null, successReturnCode: '0000'&#125;; 尝试其他方法和后台做数据交互这个问题是我在做第一个app中遇到的，如果不用ajax，前端有什么其他方法和后台做数据交互？my partner提出了一个可行的方法。大致思路是后端拦截前端所有页面间的跳转，前端不主动跳转页面。所有的跳转由后台协助完成。在android系统里前、后端约定好一个函数名称，如果前端调用该函数，函数的参数即是需要交互的数据。后端通过参数获取前端上传的数据。并将前端需要的结果以字符串的形式返回（可以是url，也可以是解析后的JSON字符串） 1234var url = window.jsOjb.login('demo','123456') // demo 用户名 123456 密码 函数的返回值即成功登陆之后的url链接 if(url)&#123; window.location.href = url; &#125; 在ios系统中稍微不一样 1var url = window.location.href = ',login,name,123456'; CSS部分rem 解决页面适配问题rem 的原理就是根据html的font-size 大小，做到页面的元素宽/高度自适应。而用rem遇到的问题是：如果用js动态设置页面的font-size，页面会有一瞬间的先缩小后放大过程。我的解决方案是利用css3的媒体查询直接改变html的font-size大小。此段代码可以写在页面重置css里 12345678html&#123;font-size:32px !important;&#125;@media screen and (min-width:350px) and (max-width:374px)&#123;html&#123;font-size:35px !important;&#125;&#125;@media screen and (min-width:375px) and (max-width:413px)&#123;html&#123;font-size:37px!important;&#125;&#125;@media screen and (min-width:414px) and (max-width:639px)&#123;html&#123;font-size:41px!important;&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:64px!important;&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:72px!important;&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:75px!important;&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:80px&#125;&#125; html 部分的meta标签 123&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt; &lt;!-- ios自动识别数字为电话号码导致页面错位 --&gt;&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; input[typr=radio]表现怪异由于重置了一些css样式导致input输入框的样式变成可以复制粘贴，而不是呈点击状态故将css代码贴出来，防止再入坑 12/* 此代码会导致input单选框怪异模式*/ input:-webkit-user-modify:read-write-plaintext-only; Sticky footer 布局App常见布局点击查看 App单页面切换效果SPA加上页面切换效果堪比原生App点击查看 上下左右居中解决方案 子级宽高固定（多见于loading实现） 子级宽高不固定（多见于图片） 弹框居中解决方案（css世界给出的方案） 123456789101112131415161718192021222324.loading-wrap&#123; position:relative; width:300px; height:300px; background:#f0f0f0; margin:20px;&#125;.loading-content &#123; position:absolute; text-align:center; left:0; right:0; top:0; bottom:0; height:20px; line-height:20px; margin:auto;&#125;&lt;!--loading居中--&gt;&lt;div class=\"loading-wrap\"&gt; &lt;div class=\"loading-content\"&gt; loading .... &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718 .img-wrap &#123; position:relative; width:300px; height:300px; background:#f0f0f0; text-align:center; font-size:0; line-height:300px;&#125;.img-wrap &gt; .img &#123; max-height:200px; max-width:200px; vertical-align:middle;&#125; &lt;!--图片宽高不确定居中--&gt; &lt;div class=\"img-wrap\"&gt; &lt;img class=\"img\" src=\"../timg.jpg\" alt=\"\"&gt; &lt;/div&gt;","tags":[{"name":"rem","slug":"rem","permalink":"https://liuchao0704.github.io/tags/rem/"},{"name":"media","slug":"media","permalink":"https://liuchao0704.github.io/tags/media/"},{"name":"webApp","slug":"webApp","permalink":"https://liuchao0704.github.io/tags/webApp/"}]},{"title":"AngularJs $on、$emit、$broadcast 事件传播时机分析","date":"2017-05-17T13:43:51.000Z","path":"2017/05/17/ng-broadcast/","text":"ng事件通信的总结 事件传播的时机分析 事件传播的格式和用法比较简单。而对于事件传播的时机有可以分析的地方。其中js的执行顺序是先执行父级controller，再执行子级controller，所以当父级发出事件的时候，子级有可能接收不到事件。 12345678910111213141516171819202122232425262728293031323334353637var app = angular.module('myApp', []);app.controller('ParentCtrlrl', function($scope, $http) &#123; // 父级接收事件 $scope.$on('to-parent', function(e, data) &#123; console.log(data) &#125;); //父级直接传播事件1 $scope.$broadcast('to-child', 'x'); //父级异步传播事件2 $http.post('api.json').then(function(res) &#123; if (res.data.success) &#123; $scope.$broadcast('to-child', 'y'); &#125; &#125;) //父级点击传播事件3 $scope.click = function() &#123; $scope.$broadcast('to-child', 'z'); &#125;&#125;);app.controller('SelfCtrl', function($scope) &#123; // 子级直接传播事件1 $scope.$emit('to-parent', '1'); // 子级接收事件2 $scope.$on('to-child', function(e, data) &#123; console.log(data) &#125;);&#125;); 看一下打印结果 1231yz //点击之后出现z,而x始终未出现 思考父级controller如何在子级js执行后传播事件？我的思路是：增加一个子级向上通知的事件。子级先向父级传播事件 →父级接收到事件后 → 父级向下传播事件 → 子级接收事件 1234567891011121314151617181920212223 var app = angular.module('myApp', []); app.controller('ParentCtrlrl', function($scope, $http) &#123; // 父级接收事件之后再传播 $scope.$on('to-parent', function(e, data) &#123; console.log(data); $scope.$broadcast('to-child', 'x'); &#125;);&#125;);app.controller('SelfCtrl', function($scope) &#123; // 子级接收事件2 $scope.$on('to-child', function(e, data) &#123; console.log(data) &#125;); // 子级直接传播事件1 $scope.$emit('to-parent', '1');&#125;); 查看一下打印结果 121X","tags":[{"name":"ng-$emit","slug":"ng-emit","permalink":"https://liuchao0704.github.io/tags/ng-emit/"},{"name":"ng-$broadcast","slug":"ng-broadcast","permalink":"https://liuchao0704.github.io/tags/ng-broadcast/"}]},{"title":"Select与Datepicker插件控制日期","date":"2017-04-23T06:57:33.000Z","path":"2017/04/23/datepicker/","text":"Date对象和Datepicker插件使用总结 Date对象和Datepicker插件使用示意图 datepicker 基本用法 123456&lt;div class=\"input-group date\" id=\"date\" data-provide=\"datepicker\"&gt; &lt;input type=\"text\" class=\"form-control\" readonly=\"readonly\" ng-disabled=\"disable\"&gt; &lt;div class=\"input-group-addon\"&gt; &lt;span class=\"glyphicon glyphicon-th\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345$(&apos;#date&apos;).datepicker(&#123; language: &apos;zh-CN&apos;, autoclose: true, format: &apos;yyyy-mm-dd&apos;&#125;); 直接将日期更新到今日 1$('#date').datepicker('update', new Date()) // 日期更新到今日 Select 改变日期预览格式 支持日/月/年视图切换 月视图写法 12345678 $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, startView: 1, maxViewMode: 1, minViewMode: 1, format: 'yyyy-mm'&#125;); 点击前后按钮实现日期自动+1/-1切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;!doctype html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;日期联动&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;!--datepicker css --&gt; &lt;link rel=\"stylesheet\" href=\"dist/css/bootstrap-datepicker.css\"&gt; &lt;script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt; &lt;/script&gt; &lt;script src=\"angular-1.3.0.js\"&gt;&lt;/script&gt; &lt;!--datepicker js --&gt; &lt;script src=\"dist/js/bootstrap-datepicker.js\"&gt;&lt;/script&gt; &lt;!--datepicker language js --&gt; &lt;script src=\"dist/locales/bootstrap-datepicker.zh-CN.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" ng-controller=\"myCtrl\"&gt; &lt;h4 class=\"col-xs-12\"&gt; Select与Datepicker插件控制日期&lt;/h4&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-5\" class=\"form-group\"&gt; &lt;select name=\"dateType\" class=\"form-control\" ng-model=\"dateType\" ng-change=\"dateTypeChange(dateType)\"&gt; &lt;option value=\"1\"&gt;日&lt;/option&gt; &lt;option value=\"2\"&gt;月&lt;/option&gt; &lt;option value=\"3\"&gt;年&lt;/option&gt; &lt;option value=\"4\"&gt;总&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"col-xs-1\" ng-click=\"gotoPreNext(0)\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-left\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"col-xs-5\"&gt; &lt;div class=\"input-group date\" id=\"date\" data-provide=\"datepicker\"&gt; &lt;input type=\"text\" class=\"form-control\" readonly=\"readonly\" ng-disabled=\"disable\"&gt; &lt;div class=\"input-group-addon\"&gt; &lt;span class=\"glyphicon glyphicon-th\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-xs-1\" ng-click=\"gotoPreNext(1)\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-rightglyphicon glyphicon-\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.dateType = '1'; // 初始化默认日期类型为日; // 为Date 添加format方法 Date.prototype.format = function(fmt) &#123; var o = &#123; \"M+\": this.getMonth() + 1, //月份 \"d+\": this.getDate(), //日 \"h+\": this.getHours(), //小时 \"m+\": this.getMinutes(), //分 \"s+\": this.getSeconds(), //秒 \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \"S\": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); &#125; for (var k in o) &#123; if (new RegExp(\"(\" + k + \")\").test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); &#125; &#125; return fmt; &#125;; $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, format: 'yyyy-mm-dd' &#125;); $('#date').datepicker('update', new Date()) // 默认当天日期 $scope.disable = false; // 默认可选日期 $scope.dateTypeChange = function(type) &#123; var str = ''; switch (parseInt(type)) &#123; case 1: $scope.disable = false; $('#date').datepicker('remove'); $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, format: 'yyyy-mm-dd' &#125;); $('#date').datepicker('update', new Date()) break; case 2: $scope.disable = false; $('#date').datepicker('remove'); $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, startView: 1, maxViewMode: 1, minViewMode: 1, format: 'yyyy-mm' &#125;); str = new Date().format('yyyy-MM') $('#date').datepicker('update', str) break; case 3: $scope.disable = false; $('#date').datepicker('remove'); $('#date').datepicker(&#123; language: 'zh-CN', autoclose: true, startView: 2, maxViewMode: 2, minViewMode: 2, format: 'yyyy' &#125;); str = new Date().format('yyyy') $('#date').datepicker('update', str) break; case 4: $scope.disable = true; $('#date input').val('---'); $('#date').datepicker('remove'); break; default: break; &#125; &#125; // 前后按钮改变日期 前一天 后一天 $scope.gotoPreNext = function(flag)&#123; var curDate = $('#date input').val(); var dateY = parseInt(curDate.split('-')[0])|| parseInt(curDate); // 年比较特殊 不需要分割直接使用 var dateM = parseInt(curDate.split('-')[1])|| 0; var dateD = parseInt(curDate.split('-')[2])|| 0; debugger; switch (parseInt($scope.dateType)) &#123; case 1: if(flag)&#123; $('#date').datepicker('update', new Date(dateY, dateM-1 , dateD + 1)) &#125;else&#123; $('#date').datepicker('update', new Date(dateY, dateM-1 , dateD -1)) &#125; break; case 2: if(flag)&#123; $('#date').datepicker('update', new Date(dateY, dateM, 1)); &#125;else&#123; $('#date').datepicker('update', new Date(dateY, dateM-2, 1)) &#125; break; case 3: if(flag)&#123; $('#date').datepicker('update', new Date(dateY + 1,0,1)) &#125;else&#123; $('#date').datepicker('update', new Date(dateY - 1,0,1)) &#125; break; default: break; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"date","slug":"date","permalink":"https://liuchao0704.github.io/tags/date/"}]},{"title":"AngularJs动态控制多选框全选与全不选并且打印选中的值","date":"2017-04-10T12:34:40.000Z","path":"2017/04/10/multiselect/","text":"AngularJs获取多选框处理的值 多选框示意图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=\"myApp\" ng-controller=\"vipApplyEditCtrl\"&gt; &lt;div&gt; &lt;div ng-repeat=\"color in colors\"&gt; &lt;input type=\"checkbox\" ng-checked=\"isChecked(color.id)\" ng-click=\"updateSelection($event,color.id)\" /&gt;&#123;&#123;color.name&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; Selected : &#123;&#123;selected&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller(\"vipApplyEditCtrl\", function($scope) &#123; $scope.colors = [ &#123;id : 1, name : 'black'&#125;, &#123;id : 2, name : 'red'&#125;, &#123;id : 3, name : 'blue'&#125;, &#123;id : 4, name : 'yellow'&#125;, &#123;id : 5, name : 'green'&#125;, &#123;id : 6, name : 'white'&#125; ] ; $scope.selected = [] ; $scope.isChecked = function(id)&#123; return $scope.selected.indexOf(id) &gt;= 0 ; &#125; ; $scope.updateSelection = function($event,id)&#123; var checkbox = $event.target ; var checked = checkbox.checked ; if(checked)&#123; $scope.selected.push(id) ; &#125;else&#123; var idx = $scope.selected.indexOf(id) ; $scope.selected.splice(idx,1) ; &#125; &#125; ; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过ng-checked 属性选中某个多选框1$scope.selected = [2] ; // 支持预先选中某个选项 增加全选和取消全选的按钮 1、增加一个开关控制单选或者全选(可以用checkbox 或者 radio) 2、动态改变select数组 3、单个选项进行操作的时候判断是否改变了全选或者非全选的状态，如果改变动态更新 4、涉及到checkbox 和 radio 操作请使用ng-change来代替ng-click，否则model值为undefined或者未更新 5、针对第四条补充说明如果是单纯的点击操作，不涉及到model值的传递，可以用ng-click，但是需要将model值作为函数的参数进行传递的时候请使用ng-change比较稳妥。 方案一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"angular-1.3.0.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=\"myApp\" ng-controller=\"vipApplyEditCtrl\"&gt;&lt;div&gt; &lt;input type=\"checkbox\" name=\"all\" ng-model=\"all\" ng-change=\"toSelectAll(all)\"&gt; 全选 &lt;i&gt;&#123;&#123;all&#125;&#125;&lt;/i&gt; &lt;div ng-repeat=\"color in colors\"&gt; &lt;input type=\"checkbox\" ng-checked=\"isChecked(color.id)\" ng-click=\"updateSelection($event,color.id)\" /&gt; &#123;&#123;color.name&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; Selected :&#123;&#123;selected&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller(\"vipApplyEditCtrl\", function($scope) &#123; $scope.formData = &#123;&#125;; $scope.colors = [ &#123;id : 1, name : 'black'&#125;, &#123;id : 2, name : 'red'&#125;, &#123;id : 3, name : 'blue'&#125;, &#123;id : 4, name : 'yellow'&#125;, &#123;id : 5, name : 'green'&#125;, &#123;id : 6, name : 'white'&#125; ] ; $scope.selected = [] ; $scope.isChecked = function(id)&#123; return $scope.selected.indexOf(id) &gt;= 0 ; &#125; ; $scope.updateSelection = function($event,id)&#123; var checkbox = $event.target ; var checked = checkbox.checked ; if(checked)&#123; $scope.selected.push(id); &#125;else&#123; var idx = $scope.selected.indexOf(id) ; $scope.selected.splice(idx,1) ; &#125; if($scope.selected.length == $scope.colors.length) &#123; $scope.all = true; &#125;else&#123; $scope.all = false; &#125; &#125; ; $scope.toSelectAll = function(flag)&#123; if(flag)&#123; $scope.selected = [] angular.forEach($scope.colors, function (i) &#123; $scope.selected.push(i.id); &#125;) &#125;else&#123; angular.forEach($scope.colors, function (i) &#123; $scope.selected = []; &#125;) &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 方法二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script src=\"angular-1.3.0.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=\"myApp\" ng-controller=\"vipApplyEditCtrl\"&gt;&lt;div&gt; &lt;input type=\"checkbox\" name=\"all\" ng-model=\"all\" ng-change=\"toSelectAll(all)\"&gt; 全选 &lt;i&gt;&#123;&#123;all&#125;&#125;&lt;/i&gt; &lt;div ng-repeat=\"color in colors\"&gt; &lt;input type=\"checkbox\" ng-checked=\"color.checked == true\" ng-click=\"updateSelection(color)\" /&gt; &#123;&#123;color.name&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div&gt; Selected :&#123;&#123;selected&#125;&#125;&lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller(\"vipApplyEditCtrl\", function($scope) &#123; $scope.formData = &#123;&#125;; $scope.colors = [ &#123;id : 1, name : 'black'&#125;, &#123;id : 2, name : 'red'&#125;, &#123;id : 3, name : 'blue'&#125;, &#123;id : 4, name : 'yellow'&#125;, &#123;id : 5, name : 'green'&#125;, &#123;id : 6, name : 'white'&#125; ] ; $scope.selected = [] ; $scope.updateSelection = function(obj)&#123; if(!obj.checked )&#123; obj.checked = true; $scope.selected.push(obj.id); &#125;else&#123; obj.checked = false; var idx = $scope.selected.indexOf(obj.id) ; $scope.selected.splice(idx,1) ; &#125; if($scope.selected.length == $scope.colors.length) &#123; $scope.all = true; &#125;else&#123; $scope.all = false; &#125; &#125; ; $scope.toSelectAll = function(flag)&#123; if(flag)&#123; $scope.selected = [] angular.forEach($scope.colors, function (i) &#123; i.checked = true; $scope.selected.push(i.id); &#125;) &#125;else&#123; angular.forEach($scope.colors, function (i) &#123; i.checked = false; $scope.selected = []; &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"checkbox","slug":"checkbox","permalink":"https://liuchao0704.github.io/tags/checkbox/"}]},{"title":"Ng-repeat下ng-model与对象拷贝的简单分析","date":"2017-03-09T12:27:36.000Z","path":"2017/03/09/ngRepeat/","text":"关于对象的总结 ng-model绑定到$parent上1234567&lt;ul &gt; &lt;h1 ng-bind=\"radio\"&gt;&lt;/h1&gt; &lt;li ng-repeat=\"x in records\"&gt; &lt;input type=\"radio\" name=\"radio\" ng-model=\"radio\" value=\"&#123;&#123;x&#125;&#125;\"&gt; &lt;label ng-bind=\"x\"&gt;&lt;/label&gt; &lt;/li&gt;&lt;/ul&gt; 当我们选中单选框的时候发现并没有想预期一样显示ng-model的值。这是因为处在ng-repeat之间的代码，对全局的$scope里变量的内容是不可见的，像不是全局$scope里的成员。而是为ng-repeat创建的子scope里面的。所以要引用全局$scope里的成员，你可以使用$parent来引用全局的$scope,修改如下。 12&lt;h1 ng-bind=\"radio\"&gt;&lt;/h1&gt;&lt;input type=\"radio\" name=\"radio\" ng-model=\"$parent.radio\" value=\"&#123;&#123;x&#125;&#125;\"&gt; 这次点击input单选框，绑定的值就能显示了。 ng-model绑定到对象的属性上这次我们将ng-model 绑定到对象上的属性下面，此时不用$parent 也能显示ng-model了1234567&lt;ul &gt; &lt;h1 ng-bind=\"radio2.radio\"&gt;&lt;/h1&gt; &lt;li ng-repeat=\"x in records\"&gt; &lt;input type=\"radio\" name=\"radio2\" ng-model=\"radio2.radio\" value=\"&#123;&#123;x&#125;&#125;\"&gt; &lt;label ng-bind=\"x\"&gt;&lt;/label&gt; &lt;/li&gt;&lt;/ul&gt; 原理分析根据js对象是属于引用类型的特点来将值绑定在对象的属性上，实现了自动更新。 angular下的对象拷贝1angular.copy(source, [destination]); 复制一个对象或者一个数组（好吧，万物皆对象，数组也是一个对象）。 如果省略了destination，一个新的对象或数组将会被创建出来; 如果提供了destination，则source对象中的所有元素和属性都会被复制到destination中 如果source不是对象或数组（例如是null或undefined）, 则返回source; 如果source和destination类型不一致，则会抛出异常。 注意：这个是单纯复制覆盖，不是类似继承。","tags":[{"name":"ng-repeat","slug":"ng-repeat","permalink":"https://liuchao0704.github.io/tags/ng-repeat/"}]},{"title":"Angular 表单验证","date":"2017-02-28T14:02:20.000Z","path":"2017/02/28/ng-form/","text":"form表单提交之前的验证操作以及对form表单中单选框和多选框的值获取 Form 表单的状态 属性类 描述 $valid ng-valid Boolean 告诉我们这一项当前基于你设定的规则是否验证通过 $invalid ng-invalid Boolean 告诉我们这一项当前基于你设定的规则是否验证未通过 $pristine ng-pristine Boolean 如果表单或者输入框没有使用则为True $dirty ng-dirty Boolean 如果表单或者输入框有使用到则为True 设置Form表单如果我们使用 novalidate 将不使用html5的表单验证而是使用我们自己的验证注意我们把表单提交事件绑定到form的ng-submit上并且判断表单是否合法userForm.$valid 12345 &lt;form name=\"useform\" novalidate autocomplete=\"off\" ng-submit=\"userForm.$valid &amp;&amp; submitForm()\"&gt;&lt;!-- form 表单一定要有name属性 通过name属性访问表单 input也是如此 同时关闭表单自动填充以及h5 浏览器自带验证方法 --&gt; 当表单不合法禁用提交按钮1&lt;button type=\"submit\" class=\"btn btn-danger m-t\" ng-disabled=\"useform.$invalid\"&gt;提交!&lt;/button&gt; 重置表单 (清除$dirty样式)12$scope.menuForm.$setPristine(); $scope.menuForm.$setUntouched(); input 必填/最长/最短/正则匹配123456789101112&lt;div class=\"form-group\" &gt; &lt;label&gt;Name&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" name=\"name\" ng-required=\"true\" ng-model=\"formData.name\" ng-minlength=\"3\" ng-maxlength=\"8\" ng-pattern=\"/^[a-zA-Z]+$/\" &gt;&lt;/div&gt; 使用ng-show来显示错误信息12345678910&lt;div ng-show=\"useform.name.$dirty &amp;&amp; useform.name.$invalid\"&gt; &lt;p ng-show=\"useform.name.$error.minlength\" class=\"help-block\"&gt; 名字太短.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.maxlength\" class=\"help-block\"&gt; 名字太长.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.required\" class=\"help-block\"&gt; 名字是必填的.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.pattern\" class=\"help-block\"&gt; 名字只能是字母.&lt;/p&gt;&lt;/div&gt; 使用ng-class 给表单添加错误样式因为我们使用了 Bootstrap, 我们将就使用它们提供的类(has-error). 这样就能围绕我们的form-group获得漂亮的错误信息和颜色. 12&lt;div class=\"form-group\" ng-class=\"&#123;'has-error':useform.name.$dirty &amp;&amp; (useform.name.$invalid || useform.$submitted)&#125;\"&gt;&lt;/div&gt; input[checkbox] 多选框12345678910111213&lt;!-- MULTIPLE CHECKBOXES --&gt;&lt;label&gt;Favorite Colors&lt;/label&gt;&lt;div class=\"form-group\"&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.red\"&gt; Red &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.blue\"&gt; Blue &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.green\"&gt; Green &lt;/label&gt;&lt;/div&gt; 当选择多选框的时候把formData.favoriteColors打印出来 1\"favoriteColors\":&#123;\"red\":true,\"blue\":true,\"green\":true&#125;&#125; input[checkbox] 添加 value 属性如果我们不想简单的设置checkoxs上ng-model为true或者false,而是希望ng-model能和checkbox 上的value绑定，那该如何绑定呢？ 1&lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.red\" value=\"red\"&gt; Red 我在 vaule上尝试写了个值,打印输出一下看看,结果还是true、false切换并没有达到我们想要的效果，看来checkbox的值绑定需要用到其他方法。 1\"favoriteColors\":&#123;\"red\":true,\"blue\":true,\"green\":true&#125; 原因是当未设置ngTrueValue和ngFalseValue时，checkbox默认值是true和false。如果给checkbox 赋ngTrueValue和ngFalseValue值,那么就能使用我们自定义的值了。请注意字符串添加单引号否则会报错 123456789101112&lt;!-- CUSTOM VALUE CHECKBOXES --&gt;&lt;label&gt;Personal Question&lt;/label&gt;&lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" name=\"awesome\" ng-model=\"formData.awesome\" ng-true-value=\" 'ofCourse'\" ng-false-value=\" 'iWish' \"&gt; Are you awesome? &lt;/label&gt;&lt;/div&gt; 当选择多选框的时候把formData.awesome打印出来 1&#123;\"awesome\":\"ofCourse\"&#125; input[radio] 单选框 value 选择中时的值 ngValue 选择中时的值（表达式） ngchange model更新触发 没有required属性，没办法做必填校验，所以最好初始化的时候默认选中一个。 12345678910111213&lt;label&gt;Chicken or the Egg?&lt;/label&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"chickenEgg\" value=\"chicken\" ng-model=\"formData.chickenEgg\"&gt; Chicken &lt;/label&gt; &lt;/div&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"chickenEgg\" value=\"egg\" ng-model=\"formData.chickenEgg\"&gt; Egg &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; 选中egg把值先打印出来 1\"chickenEgg\":\"egg\" 扩展1：input[radio] 控制 input的 disable 属性场景:如果单选框选择true,则只有true对应的输入框属性可以编辑,如果单选框选择false,则只有false对应的输入框属性可以编辑。 1234div&gt; &lt;input type=\"text\" ng-disabled=\"formData.chickenEgg == 'egg'\" ng-required=\"formData.chickenEgg == 'chicken'\" value=\"chicken\"&gt; &lt;input type=\"text\" ng-disabled=\"formData.chickenEgg == 'chicken'\" ng-required=\"formData.chickenEgg == 'egg'\" value=\"egg\"&gt; &lt;/div&gt; 扩展2：ng-repeat下input[radio]的ng-model详见 https://liuchao0704.github.io/2017/03/09/ngRepeat/ 扩展3：angular动态控制checkbox全选与取消全选详见 https://liuchao0704.github.io/2017/04/10/multiselect/ 下拉框 Select 值是动态生成的123&lt;select ng-model=\"formData.selected\" ng-options=\"x.id as x.name for x in users\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt;&lt;!-- 替换空白--&gt;&lt;/select&gt; 123456789$scope.users = [ &#123;name:'a',id:'1'&#125;, &#123;name:'b',id:'2'&#125;, &#123;name:'c',id:'3'&#125; ];$scope.formData = &#123; selected:'2', chickenEgg:'egg' &#125;; 提交Form表单 123456789101112$scope.submitForm = function()&#123; var param = &#123; name:$scope.formData.name &#125;; $http(&#123; url:'api/test.js', method:'post', data:param &#125;).success(function(data,header,config,status)&#123; &#125;) .error(function(data,header,config,status)&#123;&#125;); &#125;; 点击提交的时候，查看提交头 提交含有文件的Form 表单当form表单中有文件提交的时候，请求设置有些不同，因为是通过anjularjs的http请求来上传文件的，所以要让当前的request成为一个Multipart/form-data请求。 anjularjs对于post和get请求默认的Content-Type header 是application/json。通过设置‘Content-Type’: undefined，这样浏览器不仅帮我们把Content-Type 设置为 multipart/form-data，还填充上当前的boundary，如果你手动设置为： ‘Content-Type’: multipart/form-data，后台会抛出异常：the current request boundary parameter is null。 ps：通过设置 transformRequest: angular.identity ，anjularjs transformRequest function 将序列化我们的formdata object. 12345678910111213var fd = new FormData();var file1 = document.querySelector('input[name=file]').files[0];fd.append('logo1', file1);$http(&#123; method:\"POST\", url:\"api/test.js\", data:fd, headers:&#123; \"Content-Type\": undefined &#125;, transformRequest: angular.identity &#125;).success(function(data,header,config,status)&#123; &#125;) .error(function(data,header,config,status)&#123;&#125;); ps:上面的file的获取还可以通过：var file = $scope.myFile.同时要注意在js中 data: fd,不能像普通的参数一样写为：params：{ fd，…}，在GET方法中可以使用params ，在POST/PUT/PATCH/DELETE中不能使用params 来传递数据，要使用data来传递。参考：http://blog.csdn.net/wei389083222/article/details/51289704 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link href=\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; &lt;body ng-app=\"formApp\" ng-controller=\"formController\"&gt; &lt;div class=\"col-xs-12 col-sm-10 col-sm-offset-1\"&gt; &lt;h2&gt;Angular Checkboxes and Radio Buttons&lt;/h2&gt; &lt;form name=\"useform\" novalidate autocomplete=\"off\" ng-submit=\"userForm.$valid &amp;&amp; submitForm()\"&gt; &lt;!-- NAME INPUT --&gt; &lt;div class=\"form-group\" ng-class=\"&#123;'has-error':useform.name.$dirty &amp;&amp; useform.name.$invalid&#125;\"&gt; &lt;label&gt;Name&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" name=\"name\" required ng-model=\"formData.name\" ng-minlength=\"3\" ng-maxlength=\"8\" ng-pattern=\"/^[a-zA-Z]+$/\"&gt; &lt;/div&gt; &lt;div ng-show=\"useform.name.$dirty &amp;&amp; useform.name.$invalid\"&gt; &lt;p ng-show=\"useform.name.$error.minlength\" class=\"help-block\"&gt; 名字太短.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.maxlength\" class=\"help-block\"&gt; 名字太长.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.required\" class=\"help-block\"&gt;名字是必填的.&lt;/p&gt; &lt;p ng-show=\"useform.name.$error.pattern\" class=\"help-block\"&gt; 名字只能是字母.&lt;/p&gt; &lt;/div&gt; &lt;!-- =============================================== --&gt; &lt;!-- ALL OUR CHECKBOXES AND RADIO BOXES WILL GO HERE --&gt; &lt;!-- =============================================== --&gt; &lt;!-- SUBMIT BUTTON (DOESNT DO ANYTHING) --&gt; &lt;div class=\"col-md-12\" style=\"margin-bottom: 15px;\"&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-danger m-t\" ng-disabled=\"useform.$invalid\"&gt;提交!&lt;/button&gt; &lt;/form&gt; &lt;!-- MULTIPLE CHECKBOXES --&gt; &lt;label&gt;Favorite Colors&lt;/label&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.red\" value=\"red\"&gt; Red &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.blue\" value=\"blue\"&gt; Blue &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" name=\"favoriteColors\" ng-model=\"formData.favoriteColors.green\" value=\"green\"&gt; Green &lt;/label&gt; &lt;/div&gt; &lt;!-- CUSTOM VALUE CHECKBOXES --&gt; &lt;label&gt;Personal Question&lt;/label&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" name=\"awesome\" ng-model=\"formData.awesome\" ng-checked=\"formData.awesome\" ng-true-value=\" 'ofCourse'\" ng-false-value=\" 'iWish' \"&gt; Are you awesome? &lt;/label&gt; &lt;/div&gt; RADIO BUTTONS &lt;label&gt;Chicken or the Egg?&lt;/label&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"chickenEgg\" value=\"chicken\" ng-model=\"formData.chickenEgg\"&gt; Chicken &lt;/label&gt; &lt;/div&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"chickenEgg\" value=\"egg\" ng-model=\"formData.chickenEgg\"&gt; Egg &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"text\" ng-disabled=\"formData.chickenEgg == 'egg'\" ng-required=\"formData.chickenEgg == 'chicken'\" value=\"chicken\"&gt; &lt;input type=\"text\" ng-disabled=\"formData.chickenEgg == 'chicken'\" ng-required=\"formData.chickenEgg == 'egg'\" value=\"egg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;select ng-model=\"formData.selected\" ng-options=\"x.id as x.name for x in users\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; 替换空白 &lt;/select&gt; &lt;!-- SHOW OFF OUR FORMDATA OBJECT --&gt; &lt;h2&gt;Sample Form Object&lt;/h2&gt; &lt;pre&gt; &#123;&#123; formData &#125;&#125; &lt;/pre&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var formApp = angular.module('formApp', []); formApp.controller('formController', function($scope, $http) &#123; $scope.users = [&#123; name: 'a', id: '1' &#125;, &#123; name: 'b', id: '2' &#125;, &#123; name: 'c', id: '3' &#125;]; // we will store our form data in this object $scope.formData = &#123; selected: '2', chickenEgg: 'egg' &#125;; $scope.submitForm = function() &#123; /* var param = &#123; name:$scope.formData.name &#125;; $http(&#123; url:'api/test.js', method:'post', data:param &#125;).success(function(data,header,config,status)&#123; &#125;) .error(function(data,header,config,status)&#123;&#125;);*/ var fd = new FormData(); var file1 = document.querySelector('input[name=file]').files[0]; fd.append('logo1', file1); $http(&#123; method: \"POST\", url: \"api/test.js\", data: fd, headers: &#123; \"Content-Type\": undefined &#125;, transformRequest: angular.identity &#125;).success(function(data, header, config, status) &#123;&#125;) .error(function(data, header, config, status) &#123;&#125;); &#125;; &#125;); &lt;/script&gt;&lt;/html&gt;","tags":[{"name":"ng-form","slug":"ng-form","permalink":"https://liuchao0704.github.io/tags/ng-form/"}]},{"title":"Http/Cookie/LocalStroage/SessionStorage 本地化存储简单分析比较","date":"2017-02-15T14:07:18.000Z","path":"2017/02/15/cookie/","text":"分析cookie localStroage sessionStorage 之间的特点选择更适合的方式来存储页面之间的交换信息。 Cookie优点：历史悠久,浏览器支持率高。但是cookie在存储空间上有一些限制。 浏览器 cookie个数（每个域名） 单个cookie容量限制 Microsoft 50个 4KB左右(包括name、value和等号) Firefox 50个 4KB左右(包括name、value和等号) Opera 30个 4KB左右(包括name、value和等号) Chrome 53个 4KB左右(包括name、value和等号) Cookie 4 个属性 cookie的生存期属性:expires;默认情况下,cookie只在浏览器会话期存在.退出浏览器就丢失;可以用expires设置时间;退出浏览器后就不会丢失并存为客户端浏览器的cookie文件;过了时间后cookie失效,还会自动删除cookie文件. path属性:默认情况下,在同一个目录下文件可以调用; 例如:http://demo.com/c1/1.html设置的cookie可以被http://demo.com/c1/2.html调用.但不能被http://demo.com/c2/目录下的文件调用; 但如把path属性设成”/“;则在http://demo.com/下的所有文件都可调用此cookie. domain属性:例如设成”.google.com”则在.google.com下的所有服务器下的文件都可以调用cookie 1document.cookie=\"userId=320; path=/\"; 安全属性:默认情况下为false;用http协议不安全传输;true:用https等协议安全传输. 1document.cookie=\"name=value; domain=cookieDomain\"; Cookie 设置123document.cookie = 'username=admin'document.cookie = 'age=17';document.cookie=\"username=admin; age=17\"; //如果是多个键值对： Cookie 函数封装12345678910111213/*添加cookie*/ function addCookie(name, value, days, path) &#123; var name = escape(name); var value = escape(value); var expires = new Date(); expires.setTime(expires.getTime() + days * 3600000 * 24); //path=/，表示cookie能在整个网站下使用，path=/temp，表示cookie只能在temp目录下使用 path = path == \"\" ? \"\" : \";path=\" + path; //GMT(Greenwich Mean Time)是格林尼治平时，现在的标准时间，协调世界时是UTC //参数days只能是数字型 var _expires = (typeof days) == \"string\" ? \"\" : \";expires=\" + expires.toUTCString(); document.cookie = name + \"=\" + value + _expires + path; &#125; 执行一下函数 1addCookie('cookie',222,3); 在本地打开网页会发现Cookie,并且路径是当前文件夹下的路径 Cookie 读取12345678function getCookie(name)&#123;var arr,reg=new RegExp(\"(^| )\"+name+\"=([^;]*)(;|$)\");if(arr=document.cookie.match(reg))return unescape(arr[2]);elsereturn null;&#125; Cookie 删除如果设置的时候 path=&#39;/xxx&#39; 那么删除掉时候也要相应的添加上path 1234567 /*删除cookie*/ function deleteCookie(name,path)&#123; /**根据cookie的键，删除cookie，其实就是设置其失效**/ var name = escape(name); var expires = new Date(0); path = path == \"\" ? \"\" : \";path=\" + path; document.cookie = name + \"=\"+ \";expires=\" + expires.toUTCString() + path;&#125; localStrogelocalStroge 设置1localStorage.setItem(key,value);//设置key 为 value localStroge 获取1localStorage.getItem(key);//获取key的值 localStroge 清除单个Key1localStorage.removeItem(key);//清除key的值 localStroge 清除所有1localStorage.clear();//一次性清除所有的键值对 如果要使cookie在当前整个网站下可用,可以将cookie_dir指定为根目录,例如：1document.cookie=”userid=320;path=/”; localstorage的存储范围就是当前整个网站，不存在指定访问范围这一说。 localStroge遍历存储的数据当你不清楚本地localStorage存储了多少数据的时候，用key(index)方法绝对是一个不错的选择，key方法可以遍历localStorage存储的key。写个简单的例子： 123for(i=0;i&lt;localStorage.length;i++)&#123; document.write(localStorage.key(i)+\":\"+localStorage.getItem(localStorage.key(i))+\"&lt;br/&gt;\");&#125; localStrogeJSON存储当需要存储的数据很多时，可以将数据存储到数组中并转换成JSON格式的数据。 JSON.stringify(data) 将对象转换成JSON格式的数据串。 JSON.parse(data)将数据解析成对象并返回解析后的对象。 这样说或许不太好懂，直接上例子： 123var arr = &#123;\"name\":\"moomoo\",\"age\":2,\"eat\":\"apple\"&#125;;localStorage.setItem(\"arr\",JSON.stringify(arr));arr = JSON.parse(localStorage.getItem(\"arr\")); sessionStorage设置sessionStorage 用法基本同localStroge ,但是当网页关闭重新打开的时候,sessionStorage就会清除。网页重新刷新并不会被清除。 12345678910sessionStorage(); function sessionStorage() &#123; var arr = &#123; \"name\": \"pp\", \"age\": 33, \"eat\": \"pear\" &#125;; var sessionStorage = window.sessionStorage; // 请注意使用window.sessionStorage 否则会报错 sessionStorage.setItem(\"yy\", JSON.stringify(arr)); &#125; 下面是完整的HMTL代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203 &lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;cookie 跨域和解决方案&lt;/title&gt; &lt;link href=\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"col-xs-12\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 \"&gt; &lt;h2&gt; cookie设置&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"col-xs-12\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 \"&gt; &lt;label for=\"set-cookie-name \" class=\"col-xs-2\"&gt;name&lt;/label&gt; &lt;input type=\"text\" class=\"col-xs-2\" id=\"set-cookie-name\"&gt; &lt;label for=\"set-cookie-value\" class=\"col-xs-2\"&gt;value&lt;/label&gt; &lt;input type=\"text\" class=\"col-xs-2\" id=\"set-cookie-value\"&gt; &lt;button id=\"set-cookie-btn\" type=\"button\" class=\"btn btn-success col-xs-3 col-xs-offset-1 \"&gt; 点击设置cookie &lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-4 \"&gt; &lt;input type=\"text\" class=\"col-xs-5\" id=\"get-cookie-input\"&gt; &lt;button id=\"get-cookie-btn\" class=\" btn btn-info col-xs-5 col-xs-offset-1\"&gt; 获取cookie 按钮&lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-2 \"&gt; &lt;button id=\"del-cookie-btn\" class=\" btn btn-danger col-xs-10 col-xs-offset-1\"&gt; 删除cookie 按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-8 \"&gt; &lt;h2&gt;Localstroge设置&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"col-xs-12\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 \"&gt; &lt;label for=\"set-localstroge-name \" class=\"col-xs-2\"&gt;name&lt;/label&gt; &lt;input type=\"text\" class=\"col-xs-2\" id=\"set-localstroge-name\"&gt; &lt;label for=\"set-localstroge-value\" class=\"col-xs-2\"&gt;value&lt;/label&gt; &lt;input type=\"text\" class=\"col-xs-2\" id=\"set-localstroge-value\"&gt; &lt;button id=\"set-localstroge-btn\" type=\"button\" class=\"btn btn-success col-xs-3 col-xs-offset-1 \"&gt; 点击设置localstroge &lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-4 \"&gt; &lt;input type=\"text\" class=\"col-xs-5\" id=\"get-localstroge-input\"&gt; &lt;button id=\"get-localstroge-btn\" class=\" btn btn-info col-xs-5 col-xs-offset-1\"&gt; 获取localstroge 按钮&lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-2 \"&gt; &lt;button id=\"del-localstroge-btn\" class=\" btn btn-danger col-xs-10 col-xs-offset-1\"&gt; 删除localstroge 按钮&lt;/button&gt; &lt;/div&gt; &lt;div class=\"col-xs-12 \" style='margin-top: 20px;'&gt; &lt;button id=\"del-localstroge-all-btn\" class=\" btn btn-danger col-xs-3 col-xs-offset-2\"&gt; 删除所有localstroge 按钮&lt;/button&gt; &lt;button id=\"set-localstroge-arr-btn\" class=\" btn btn-primary col-xs-3 col-xs-offset-1\"&gt; 设置localstrogeArray按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-8 \"&gt; &lt;h2&gt;Sessionstroge设置&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"col-xs-12\"&gt; &lt;button id=\"set-sessionstroge-arr-btn\" class=\" btn btn-infro col-xs-3 col-xs-offset-1\"&gt; 设置sessionstrogeArray按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt; &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; if (window.localStorage) &#123; console.log('localStorage') &#125; else &#123; console.log('not support localStorage') &#125; if (window.sessionStorage) &#123; console.log('sessionStorage') &#125; else &#123; console.log('not support sessionStorage') &#125; $('#set-cookie-btn').on('click', function() &#123; var name = $('#set-cookie-name').val(); var value = $('#set-cookie-value').val(); if (name !== null &amp;&amp; value !== null) &#123; addCookie(name, value, 3, '/setcookie'); &#125; &#125;) $('#get-cookie-btn').on('click', function() &#123; var name = $('#set-cookie-name').val(); var value = getCookie(name); $('#get-cookie-input').val(value); &#125;) $('#del-cookie-btn').on('click', function() &#123; var name = $('#set-cookie-name').val(); deleteCookie(name); &#125;) $('#set-localstroge-btn').on('click', function() &#123; var key = $('#set-localstroge-name').val(); var value = $('#set-localstroge-value').val(); if (name !== null &amp;&amp; value !== null) &#123; localStorage.setItem(key, value); &#125; &#125;) $('#get-localstroge-btn').on('click', function() &#123; var key = $('#set-localstroge-name').val(); var value = localStorage.getItem(key); $('#get-localstroge-input').val(value); &#125;) $('#del-localstroge-btn').on('click', function() &#123; var key = $('#set-localstroge-name').val(); localStorage.removeItem(key); &#125;) $('#del-localstroge-all-btn').on('click', function() &#123; localStorage.clear(); &#125;) $('#set-localstroge-arr-btn').on('click', function() &#123; setLocalstrogeArray(); &#125;) function setLocalstrogeArray() &#123; var arr = &#123; \"name\": \"moomoo\", \"age\": 2, \"eat\": \"apple\" &#125;; localStorage.setItem(\"arr\", JSON.stringify(arr)); arr = JSON.parse(localStorage.getItem(\"arr\")); console.log(arr) &#125; $('#set-sessionstroge-arr-btn').on('click', function() &#123; sessionStorage(); &#125;) function sessionStorage() &#123; var arr = &#123; \"name\": \"pp\", \"age\": 33, \"eat\": \"pear\" &#125;; var sessionStorage = window.sessionStorage; sessionStorage.setItem(\"yy\", JSON.stringify(arr)); &#125; &#125;); /*添加cookie*/ function addCookie(name, value, days, path) &#123; var name = escape(name); var value = escape(value); var expires = new Date(); expires.setTime(expires.getTime() + days * 3600000 * 24); //path=/，表示cookie能在整个网站下使用，path=/temp，表示cookie只能在temp目录下使用 path = path == \"\" ? \"\" : \";path=\" + path; //GMT(Greenwich Mean Time)是格林尼治平时，现在的标准时间，协调世界时是UTC //参数days只能是数字型 var _expires = (typeof days) == \"string\" ? \"\" : \";expires=\" + expires.toUTCString(); document.cookie = name + \"=\" + value + _expires + path; &#125; /*获取cookie*/ function getCookie(name) &#123; var arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\"); if (arr = document.cookie.match(reg)) return unescape(arr[2]); else return null; &#125; /*删除cookie*/ function deleteCookie(name, path) &#123; /**根据cookie的键，删除cookie，其实就是设置其失效**/ var name = escape(name); var expires = new Date(0); path = path == \"\" ? \"\" : \";path=\" + path; document.cookie = name + \"=\" + \";expires=\" + expires.toUTCString() + path; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"cookie","slug":"cookie","permalink":"https://liuchao0704.github.io/tags/cookie/"},{"name":"localStroage","slug":"localStroage","permalink":"https://liuchao0704.github.io/tags/localStroage/"},{"name":"sessionStorage","slug":"sessionStorage","permalink":"https://liuchao0704.github.io/tags/sessionStorage/"}]},{"title":"Gulp自动化构建工具小总结","date":"2017-02-12T12:32:50.000Z","path":"2017/02/12/gulpAuto/","text":"使用gulp一段时间了，编译less省时省力，记录一下自己的安装过程，也算是比较详细的gulp使用教程了。 本教程使用的工具以及安装环境 node.js git windows 完成效果 自动编译less文件生成css文件 当css,js 文件发生更改的时候浏览器自动为我们刷新 清除缓存,自动为css,js添加版本号例如 href=&quot;css/app.css?v=98ad83c3b4&quot; 1.安装node.js、git2.全局安装gulp 1$ npm install gulp -g 3.本地安装 gulp老规矩E盘下新建文件夹(比如www，注意不要有中文名称)并执行 1$ npm init npm init命令会为你创建一个package.json文件，这个文件保存着这个项目相关信息。比如你用到的各种依赖（这里主要是插件）（终端会自动出现下面内容，这里先随便填就行）创建完之后，我们执行下本地安装的命令：1$ npm install gulp --save-dev 执行完之后，node将创建node_modules文件夹，里面有个gulp文件夹。 4. 项目目录结构 在E盘/www文件夹下面我们使用app文件夹作为开发目录（所有的源文件都放在这下面），dist文件夹用来存放生产环境下的内容。这些文件名，你想怎么起都行，但请务必记住你的目录结构。现在来创建gulpfile.js。 5. 第一个gulp 任务你需要先在文件根目录下创建一个gulpfile.js文件，查看一下之前的文件结构。 在文件里面输入这样的代码 var gulp = require(&#39;gulp&#39;);这行命令告知Node去node_modules中查找gulp包，先局部查找，找不到就去全局环境中查找。找到之后就会赋值给gulp变量，然后我们就可以使用它了。 简单的任务如下所示：123gulp.task('task-name', function() &#123; // Stuff here &#125;); task-name 是给你的任务起的名字，稍后在命令行中执行gulp task-name，将运行该任务。写个HelloWorld，是这样的：1234var gulp = require('gulp'); gulp.task('hello', function() &#123; console.log('Hello World!'); &#125;); 命令行中执行：$ gulp hello 输出’Hello World!’ 表示成功了。 gulp任务通常会包含两个特定的Gulp方法和一系列Gulp插件。12345gulp.task('task-name', function () &#123; return gulp.src('source-files') // Get source files with gulp.src .pipe(aGulpPlugin()) // Sends it through a gulp plugin .pipe(gulp.dest('destination')) // Outputs the file in the destination folder&#125;) 6.简单的less 任务由于本人用的是less 所以这里讲一下less插件 。其实less 和 sass插件安装几乎是同理可得，引入插件的同时首先要安装一下插件 1$ npm install gulp-less --save-dev 记得在app 文件夹下有less文件夹 并且在less文件夹下面新建style.less文件。找到index.hmtl 并引入样式 打开之前的gulpfile.js 添加一下less任务 123456var less = require('gulp-less'); gulp.task('less', function () &#123; gulp.src(['app/less/style.less']) .pipe(less()) .pipe(gulp.dest('app/css')); //将会在app/css下生成style.css &#125;); 7. Node 通配符通配符是一种匹配模式，允许你匹配到多个文件。不止是Node，很多平台都有，有点像正则表达式。使用通配符，计算机检查文件名和路径进行匹配。大部分时候，我们只需要用到下面4种匹配模式： *.scss： * 号匹配当前目录任意文件，所以这里 *.scss 匹配当前目录下所有scss文件 **/*.scss：匹配当前目录及其子目录下的所有scss文件。 !not-me.scss:!号移除匹配的文件，这里将移除not-me.scss *.+(scss|sass) ：+号后面会跟着圆括号，里面的元素用|分割，匹配多个选项。这里将匹配scss和sass文件。 改造一下less 任务 12345gulp.task('less', function() &#123; return gulp.src('app/less/**/*.less') .pipe(less()) .pipe(gulp.dest('app/css')) &#125;) 8.自动编译 监听任务现在我们能处理多个文件了，但是不想每次都要执行命令，怎么办？Gulp就是为懒人而生的，我们可以使用watch命令，自动检测并执行。 Gulp提供watch方法给我们，语法如下： 12//Gulp watch syntax gulp.watch('files-to-watch', ['tasks', 'to', 'run']); 所以同时监听多个less 任务就是 123gulp.task('watch', function()&#123; gulp.watch('app/less/**/*.less', ['less']); &#125;) 当编译less时出现语法错误或者其他异常，会终止watch事件，通常需要查看命令提示符窗口才能知道，这并不是我们所希望的，所以我们需要处理出现异常并不终止watch事件（gulp-plumber），并提示我们出现了错误（gulp-notify）。 安装两个新插件 12$ npm install gulp-plumber --save-dev$ npm install gulp-notify --save-dev 继续修改一下less任务12345678var notify = require('gulp-notify'); var plumber = require('gulp-plumber'); gulp.task('less', function()&#123; return gulp.src('app/less/**/*.less') .pipe(plumber(&#123;errorHandler: notify.onError('Error: ')&#125;)) .pipe(less()) .pipe(gulp.dest('app/css')) &#125;); 9.使用Browser Sync自动刷新浏览器记得引入新插件首先要安装1$ npm install browser-sync --save-dev 在gulpfile.js中 新建任务1var browserSync = require('browser-sync'); 我们创建一个broswerSync任务，我们需要告知它，根目录在哪里。 1234567gulp.task('browserSync', function() &#123; browserSync(&#123; server: &#123; baseDir: 'app' &#125;, &#125;) &#125;) 我们稍微修改一下之前的代码，让每次css文件更改都刷新一下浏览器： 123456789gulp.task('less', function()&#123; return gulp.src('app/less/**/*.less') .pipe(plumber(&#123;errorHandler: notify.onError('Error: ')&#125;)) .pipe(less()) .pipe(gulp.dest('app/css')) .pipe(browserSync.reload(&#123; stream: true &#125;)) &#125;); 现在我们配置好BroswerSync了，我们需要运行这两个命令。我们可以在watch任务之前告知gulp，先把browserSync和less任务执行了再说。 语法如下： 123gulp.task('watch', ['array', 'of', 'tasks', 'to', 'complete','before', 'watch'], function ()&#123; // ... &#125;) 不止是less修改的时候需要刷新浏览器吧？js,html 改变都要刷新浏览器 ： 12345gulp.task('watch',['browserSync', 'less'], function()&#123; gulp.watch('app/less/**/*.less', ['less']); gulp.watch('app/*.html', browserSync.reload); gulp.watch('app/js/**/*.js', browserSync.reload); &#125;) 好了至此我们已经完成了所有的操作。$ gulp watch一下就能实现自动编译less 并且根据css ,html 等文件的改变自动刷新浏览器了。 以上参考资料： http://www.tuicool.com/articles/QzaqAbF http://www.ydcss.com/archives/18 http://www.ydcss.com/archives/34 10. BrowserSync 代理模式查看一下之前的gulpfile.js1234567gulp.task('browserSync', function() &#123; browserSync(&#123; server: &#123; baseDir: 'app' &#125;, &#125;) &#125;) 这个命令用于纯静态站点，也就是仅一些.html文件的情况。如果是动态站点，则使用代理模式。例如PHP站点，已经建立了一个本地服务器如http://localhost:8080，此时会是这样的命令，我们来做个修改 12345gulp.task('browserSync', function() &#123; browserSync(&#123; proxy: \"http://localhost:8080/xxx/app/\" //这个xxx文件夹稍后根据实际情况而定 &#125;) &#125;) 这样手机也可以访问电脑里面的网站了 $ gulp watch一下 电脑、手机端可以自动刷新了。最后分享一下 gulpfile.js 代码 12345678910111213141516171819202122232425262728var gulp = require('gulp'), less = require('gulp-less'), notify = require('gulp-notify'), plumber = require('gulp-plumber'), browserSync = require('browser-sync'); gulp.task('hello', function() &#123; console.log('Hello World!'); &#125;); gulp.task('less', function()&#123; return gulp.src('app/less/**/*.less') .pipe(plumber(&#123;errorHandler: notify.onError('Error: ')&#125;)) .pipe(less()) .pipe(gulp.dest('app/css')) .pipe(browserSync.reload(&#123; stream: true &#125;)) &#125;); gulp.task('watch',['browserSync', 'less'], function()&#123; gulp.watch('app/less/**/*.less', ['less']); gulp.watch('app/*.html', browserSync.reload); gulp.watch('app/js/**/*.js', browserSync.reload); &#125;) // Browser-sync task, only cares about compiled CSS gulp.task('browserSync', function() &#123; browserSync(&#123; proxy: \"http://127.0.0.1/xxx/app/\" //xxx 根据实际情况而定 &#125;) &#125;) 11.自动为css，js 增加版本号gulp 在原html文件上自动化添加js、css版本号原理 修改js和css文件 通过对js,css文件内容进行hash运算，生成一个文件的唯一hash字符串(如果文件修改则hash号会发生变化) 替换html中的js,css文件名，生成一个带版本号的文件名 原html文件代码 12&lt;link rel=\"stylesheet\" href=\"../css/default.css\"&gt;&lt;script src=\"../js/app.js\"&gt;&lt;/script&gt; 预期效果：在原目录结构下html文件代码 12&lt;link rel=\"stylesheet\" href=\"../css/default.css?v=5a636d79c4\"&gt;&lt;script src=\"../js/app.js?v=3a0d844594\"&gt;&lt;/script&gt; 安装插件 123npm install --save-dev gulp-revnpm install --save-dev gulp-rev-collectornpm install --save-dev run-sequence 继续修改gulpfile.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//引入gulp和gulp插件var gulp = require('gulp'), runSequence = require('run-sequence'), rev = require('gulp-rev'), revCollector = require('gulp-rev-collector');//定义css、js源文件路径var cssSrc = 'css/*.css', jsSrc = 'js/*.js';//CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revCss', function()&#123; return gulp.src(cssSrc) .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('rev/css'));&#125;);//js生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revJs', function()&#123; return gulp.src(jsSrc) .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('rev/js'));&#125;);//Html替换css、js文件版本gulp.task('revHtml', function () &#123; return gulp.src(['rev/**/*.json', 'View/*.html'])//views是本地html文件的路径，可自行配置*/ .pipe(revCollector()) .pipe(gulp.dest('View'));///*Html更换css、js文件版本,WEB-INF/views也是和本地html文件的路径一致*/&#125;);//开发构建gulp.task('dev', function (done) &#123; condition = false; runSequence( ['revCss'], ['revJs'], ['revHtml'], done);&#125;);gulp.task('default', ['dev']); 执行gulp命令后的效果 123456//rev目录下生成了manifest.json对应文件&#123; \"default.css\": \"default-803a7fe4ae.css\"&#125;&lt;link rel=\"stylesheet\" href=\"../css/default-803a7fe4ae.css\"&gt;&lt;script src=\"../js/app-3a0d844594.js\"&gt;&lt;/script&gt; 很显然这不是我们需要的效果,所以我们要继续修改 123打开node_modules\\gulp-rev\\index.js第144行 manifest[originalFile] = revisionedFile;更新为: manifest[originalFile] = originalFile + '?v=' + file.revHash; 123打开nodemodules\\rev-path\\index.js第10行 return filename + '-' + hash + ext;更新为: return filename + ext; 123打开node_modules\\gulp-rev-collector\\index.js第31行if ( !_.isString(json[key]) || path.basename(json[key]).replace(new RegExp( opts.revSuffix ), ' ') !== path.basename(key) ) &#123;更新为: if ( !_.isString(json[key]) || path.basename(json[key]).split('?')[0] !== path.basename(key) ) &#123; 再执行gulp命令，得到的结果如下(效果正确): 12&lt;link rel=\"stylesheet\" href=\"../css/default.css?v=33379df310?v=803a7fe4ae\"&gt;&lt;script src=\"../js/app.js?v=3a0d844594?v=3a0d844594\"&gt;&lt;/script&gt; 有没有发现，会在版本号后面再添加一个版本号，因为gulp只替换了原来文件名，这样又不符合预期效果了，所以我们想到，还需要修改插件的替换正则表达式。 123打开node_modules\\gulp-rev-collector\\index.js第117行 regexp: new RegExp( '([\\/\\\\\\\\\\'\"])' + pattern, 'g' ),更新为: regexp: new RegExp( '([\\/\\\\\\\\\\'\"])' + pattern+'(\\\\?v=\\\\w&#123;10&#125;)?', 'g' ), 现在你不管执行多少遍gulp命令，得到的html效果都是 12&lt;link rel=\"stylesheet\" href=\"../css/default.css?v=5a636d79c4\"&gt;&lt;script src=\"../js/app.js?v=3a0d844594\"&gt;&lt;/script&gt; 以上参考资料：https://my.oschina.net/enjoymore/blog/830622 最后分享一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var gulp = require('gulp'), less = require('gulp-less'), notify = require('gulp-notify'), plumber = require('gulp-plumber'), browserSync = require('browser-sync'), runSequence = require('run-sequence'), rev = require('gulp-rev'), revCollector = require('gulp-rev-collector');// 定义css js 路径var cssUrl = 'src/css/*.css', jsUrl = 'src/js/*.js';// hello 任务gulp.task('hello', function() &#123; console.log('Hello World!');&#125;);//less 任务gulp.task('less', function() &#123; return gulp.src('src/css/less/app.less') .pipe(plumber(&#123; errorHandler: notify.onError('Error: &lt;%= error.message %&gt;') &#125;)) .pipe(less()) .pipe(gulp.dest('src/css')) .pipe(browserSync.reload(&#123; stream: true &#125;))&#125;);// 监听任务gulp.task('watch', ['browserSync', 'less'], function() &#123; gulp.watch('src/css/less/*.less',['less']); gulp.watch('src/css/app.css',['dev']); gulp.watch('src/js/*.js',['dev']); gulp.watch('src/*.html',browserSync.reload);&#125;)// Browser-sync task, only cares about compiled CSSgulp.task('browserSync', function() &#123; browserSync(&#123; proxy: \"http://127.0.0.1/XXX/src/#/\" //根据实际情况写 &#125;)&#125;)//CSS生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revCss', function() &#123; return gulp.src(cssUrl) .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('rev/css'));&#125;);//js生成文件hash编码并生成 rev-manifest.json文件名对照映射gulp.task('revJs', function() &#123; return gulp.src(jsUrl) .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('rev/js'));&#125;);//Html更换css、js文件版本gulp.task('revHtml', function() &#123; return gulp.src(['rev/**/*.json', 'src/*.html']) /*WEB-INF/views是本地html文件的路径，可自行配置*/ .pipe(revCollector()) .pipe(gulp.dest('src/')); /*Html更换css、js文件版本,WEB-INF/views也是和本地html文件的路径一致*/&#125;);//开发构建gulp.task('dev', function(done) &#123; condition = false; runSequence( ['revCss'], ['revJs'], ['revHtml'], done);&#125;);//gulp.task('default', ['dev']);","tags":[{"name":"gulp","slug":"gulp","permalink":"https://liuchao0704.github.io/tags/gulp/"}]},{"title":"Date对象学习","date":"2017-02-08T13:40:44.000Z","path":"2017/02/08/date/","text":"关于 Date 对象处理方法 利用Date()构造函数可以创建指定时间日期对象，例如:12345678910var theDate = new Date();console.log(theDate);console.log('今年：' + theDate.getFullYear() + '\\n') // 获取年份console.log('今月：' + (parseInt(theDate.getMonth())+1) + '\\n') // 获取月 console.log('今日：' + theDate.getDate() + '\\n') // 获取日console.log('星期：' + theDate.getDay() + '\\n') // 获取星期console.log('小时：' + theDate.getHours() + '\\n') // 获取小时console.log('分钟：' + theDate.getMinutes() + '\\n') // 获取分钟：console.log('秒:' + theDate.getSeconds()+ '\\n') // 获取秒console.log('毫秒:' + theDate.getMilliseconds() + '\\n') // 获取毫秒 上面是对于Date()构造函数最简单的应用了，Date对象具有多种构造函数123456789new Date()new Date(milliseconds)new Date(datestring)new Date(year, month)new Date(year, month, day)new Date(year, month, day, hours)new Date(year, month, day, hours, minutes)new Date(year, month, day, hours, minutes, seconds)new Date(year, month, day, hours, minutes, seconds, microseconds) new Date()当 new Date()构造函数而不传递参数的时候，新创建的对象自动获得当前时间。以下代方便获取Date对象时间戳 12345678910var start = +new Date(); // do somethingvar stop = +new Date(), result = stop - start;// 对于支持 Date.now()的浏览器var start = Date.now(); //do somethingvar stop = Date.now(), result = stop- start; Date.parse()如果想要获取指定日期或者时间的日期对象，可以通过Date.parse()或者Date.UTC()。Date.parse()接收一个表示日期的字符串参数，然后根据这个字符串参数返回相应日期的毫秒数。 123var someDate = new Date(Date.parse('May 25,2004'));//等同于var someDate = new Date('May 25,2004') Date.UTC()Date.UTC() 方法同样也会返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC() 的参数分别是年份，基于0的月份(1月是0，2月是1)、月中的哪一天、小时数、分钟、秒、以及毫秒数。在这些参数中，只有前两个参数是必须的。其他可以忽略。其中月中的天数默认为1号，其他为0。 1var y = new Date(Date.UTC(2000,0)) 简单总结下 new Date()，没有参数的时候，创建的是 当前 时间日期对象。 new Date(milliseconds)，当参数为数字的时候，那么这个参数就是时间戳，被视为毫秒，创建一个距离1970年1月一日指定毫秒的时间日期对象。 new Date(datestring)，此参数是一个字符串，并且此字符串一定能够使用Date.parse()转换。 以下六个构造函数是精确定义: year，是一个整数，如果是0-99，那么在此基础上加1900，其他的都原样返回。 month,是一个整数，范围是0-11。 day，是一个整数，范围是1-31。 hours，是一个整数，范围是0-23。 minutes，是一个整数，范围是0-59。 seconds，是一个整数，范围是0-59. microseconds，是一个整数，范围是0-9999。 一些常用扩展 将日期变成指定格式123456789101112131415161718192021 Date.prototype.format = function (fmt) &#123; var o = &#123; \"M+\": this.getMonth() + 1, //月份 \"d+\": this.getDate(), //日 \"h+\": this.getHours(), //小时 \"m+\": this.getMinutes(), //分 \"s+\": this.getSeconds(), //秒 \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \"S\": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); &#125; for (var k in o) &#123; if (new RegExp(\"(\" + k + \")\").test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); &#125; &#125; return fmt; &#125;var NewDate = new Date().format('yyyy-MM-dd')将输出指定格式的今日日期 将指定格式的日期变成时间戳123456789function convertTimes( date )&#123; var date = date.split('-'); d = new Date(); d.setFullYear(date[0]); d.setMonth(date[1]-1); d.setDate(date[2]); return d.getTime();&#125; console.log( convertTimes('2017-2-3'));","tags":[{"name":"date","slug":"date","permalink":"https://liuchao0704.github.io/tags/date/"}]},{"title":"Hexo+github 部署个人网站","date":"2017-01-31T11:54:21.000Z","path":"2017/01/31/hexo-github/","text":"如果你对个人博客感兴趣想拥有一个属于自己的网站，对markdown语法有了解，有自己的github账号，平时习惯用markdown记笔记。那么用hexo来打造自己的个人网站就很容易上手了。 主要流程 安装并配置hexo github新建仓库并上传 注册七牛云用图床软件保存图片(如果需要的话) 安装并配置hexo安装hexo1$ npm install -g hexo 初始化 在电脑E盘下直接新建一个blog目录（windows系统下文件夹命名避免出现中文）12$ cd /e/blog/$ hexo init 查看一下E/blog 生成的目录 生成并启动hexo12$ hexo g # 生成$ hexo s # 启动服务 $ hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考百度。如果顺利打开的话页面是这样子的 不喜欢这个主题？ 没有关系随时都可以修改12$ cd /e/blog/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载后的主题都在themes文件夹下面。点击进去就可以看到yilia文件夹。 找到blog目录下的_config.yml文件打开并修改theme: yilia 执行一下123$ hexo clean$ hexo g$ hexo s 记住如果修改了根目录下的_config.yml 都要重新$ hexo s 才能看到效果 修改主题里面的参数 找到themes/yilia文件下的_config.yml 照着备注的中文名称开始修改吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# Headerauthor: 你独一无二的昵称menu: 主页: / 所有文章: /archives# SubNavsubnav: github: \"https://github.com/你自己的github账号\" rss: \"#\" zhihu: \"#\" #qq: \"#\" #weixin: \"#\" #jianshu: \"#\" #douban: \"#\" #mail: \"mailto:litten225@qq.com\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: # Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 请在需要打赏的文章的md文件头部，设置属性reward: true# 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 0# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # Miscellaneousbaidu_analytics: ''google_analytics: ''favicon: /favicon.png#你的头像urlavatar: 'https://liuchao-0704-1258039511.cos.ap-chengdu.myqcloud.com//*******.png'#是否开启分享share_jia: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: '#0c0d25' # 右滑板块背景 slider: 'linear-gradient(200deg,#a0cfe4,#e8c37e)' # # slider的设置slider: # 是否默认展开tags板块 showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' friends: '友链' aboutme: '关于我'friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 很高兴&lt;br&gt;你能来到这里&lt;br&gt;谢谢大家 关于头像设置（尺寸118*118 大小10-20Kb即可）我的头像是用七牛云存放。参考链接：http://www.jianshu.com/p/6dce6094b http://mpic.lzhaofu.cn 操作比较简单，如果不想设置头像的可以略过。 动手写一篇博客试试吧12$ cd /e/blog/ # 切换到blog文件$ hexo new 'hello' 回到blog/source/_posts/找到 hello.md 打开支持md语法的编辑器就可以愉快的编写了 12345678title: 鸡年大吉date: 2017-01-30 20:18:00tags: 随笔---预览内容&lt;!-- more --&gt;正文部分开始 github新建仓库并设置登录github 并新建一个仓库 请注意用户名和仓库名一一对应必须一模一样 配置SSH1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。1ssh-keygen -t rsa -C \"邮件地址\" 代码参数含义：-t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。 以上代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如12Generating public/private rsa key pair.# Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 当然，你也可以不输入文件名，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码），当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了，如：12Enter passhrase(empty fo no passphrase):# Enter same passphrase again: 最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.# Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 当你看到上面这段代码,那就说明你的 SSH key 已经创建成功，你只需要添加到github的SSH key上就可以了。 添加你的 SSH key 到 github上面去首先你需要拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容，如：1$ clip &lt; ~/.ssh/id_rsa.pub 登录你的github账号，点击头像（ Settings ）进入 &gt; SSH and GPG keys -&gt; New SSH key 把你本地生成的密钥复制到里面（key文本框中）title随便填。保存就ok了。 测试是否成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示1Are you sure you want to continue connecting (yes/no)? 输入yes，然后会看到：1Hi XXXX! Youve successfullu authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！此时你还需要配置： 12$ git config --global user.name \"你的名字\"// 你的github用户名，非昵称$ git config --global user.email \"xxx@xx.com\"// 填写你的github注册邮箱 可能出现的问题在window 系统下操作git 总会出现一些问题。如果你遇到这个提示1Could not open a connection to your authentication agent. 尝试解决的方案12islue@localhost $ ssh-agent bash --login -iislue@localhost $ ssh-add 参考资料：http://www.cnblogs.com/cheche/archive/2011/01/07/1918825.html 本地上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。首先，ssh key肯定要配置好。其次，配置_config.yml中有关deploy的部分：正确写法：1234deploy: type: git repository: git@github.com:你的名字/你的名字.github.io.git branch: master 安装一下插件1$ npm install hexo-deployer-git --save 最后一步也就是重复之前的操作123$ hexo clean$ hexo g$ hexo d 成功之后打开 https://liuchao0704.github.io/ 即可预览 总结这也是自己第一次摸索了大半天做出来的效果，遇到了一些坑。不过上网发现很多人有用hexo搭建自己的博客，资料很丰富。遇到问题也能及时百度解决之。最后时间关系有些功能没有添加：比如评论留言，比如主题里面 一些个性化配置。有机会一定会抽空改进。 我参考的资料：http://hetaoo.iteye.com/blog/2323944http://blog.csdn.net/jzooo/article/details/46781805http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html","tags":[{"name":"hexo","slug":"hexo","permalink":"https://liuchao0704.github.io/tags/hexo/"}]}]